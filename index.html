<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IGCSE Algorithm Battle Garden - Chapter 7</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #000;
            color: #fff;
        }
        
        body.pointer-locked {
            cursor: none;
        }
        
        #gameContainer {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        /* ===== UI PANELS ===== */
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.95), rgba(0, 40, 60, 0.9));
            padding: 12px 16px;
            border-radius: 12px;
            font-size: 11px;
            min-width: 160px;
            z-index: 5;
            border: 1px solid rgba(0, 200, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 100, 150, 0.3);
            pointer-events: none;
        }
        
        #stats {
            position: absolute;
            top: 10px;
            right: 10px;
            background: linear-gradient(135deg, rgba(40, 0, 40, 0.95), rgba(60, 0, 60, 0.9));
            padding: 10px 14px;
            border-radius: 12px;
            font-size: 10px;
            text-align: right;
            z-index: 5;
            border: 1px solid rgba(200, 0, 255, 0.3);
            box-shadow: 0 0 20px rgba(150, 0, 150, 0.3);
            pointer-events: none;
        }
        
        .stat-line {
            margin: 4px 0;
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        
        .stat-label { color: #aac; }
        .stat-value { 
            color: #0ff; 
            font-weight: bold; 
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.5); 
        }
        
        .bar-container {
            width: 130px;
            height: 12px;
            background: #111;
            border: 2px solid #333;
            border-radius: 6px;
            overflow: hidden;
            margin-top: 4px;
        }
        
        .bar-fill {
            height: 100%;
            transition: width 0.3s;
            box-shadow: inset 0 2px 4px rgba(255,255,255,0.2);
        }
        
        .health-fill { background: linear-gradient(90deg, #0f0, #0a0); }
        .ammo-fill { background: linear-gradient(90deg, #ff0, #fa0); }
        
        /* ===== LEVEL INDICATOR ===== */
        #levelIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 42px;
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 30px #0ff, 0 0 60px #00f;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        
        #levelIndicator.show { opacity: 1; }
        
        /* ===== POWERUP NOTIFICATION ===== */
        #powerupNotification {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            border: 2px solid #fd0;
            font-size: 14px;
            color: #fd0;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            white-space: nowrap;
        }
        
        #powerupNotification.show { opacity: 1; }

        #warningNotification {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(50, 0, 0, 0.9);
            padding: 10px 20px;
            border-radius: 5px;
            border: 2px solid #f00;
            font-size: 16px;
            font-weight: bold;
            color: #f00;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            text-transform: uppercase;
            text-shadow: 0 0 10px #f00;
        }
        
        #warningNotification.show { opacity: 1; }
        
        /* ===== QUESTION MODAL ===== */
        #questionModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.97);
            z-index: 100;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            padding: 15px;
        }
        
        #questionModal.active { display: flex; }
        
        #questionContainer {
            background: linear-gradient(135deg, rgba(0, 30, 60, 0.98), rgba(0, 50, 80, 0.95));
            border: 3px solid #0cf;
            border-radius: 16px;
            padding: 20px;
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(0, 200, 255, 0.3);
        }
        
        #questionCategory {
            font-size: 10px;
            color: #0cf;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 8px;
            opacity: 0.8;
        }
        
        #questionText {
            font-size: 16px;
            margin-bottom: 18px;
            line-height: 1.5;
            color: #fff;
        }
        
        .option-button {
            width: 100%;
            padding: 14px 16px;
            margin: 6px 0;
            background: linear-gradient(135deg, rgba(0, 80, 100, 0.6), rgba(0, 60, 80, 0.4));
            border: 2px solid #0aa;
            color: #fff;
            border-radius: 10px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }
        
        .option-button:hover {
            background: rgba(0, 200, 255, 0.3);
            transform: scale(1.02);
        }
        
        .option-button.correct {
            background: linear-gradient(135deg, rgba(0, 180, 0, 0.8), rgba(0, 140, 0, 0.6));
            border-color: #0f0;
        }
        
        .option-button.incorrect {
            background: linear-gradient(135deg, rgba(200, 0, 0, 0.8), rgba(150, 0, 0, 0.6));
            border-color: #f00;
        }
        
        #feedback {
            margin-top: 15px;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            min-height: 25px;
        }
        
        #feedback.correct { color: #0f0; text-shadow: 0 0 15px #0f0; }
        #feedback.incorrect { color: #f44; text-shadow: 0 0 15px #f00; }
        
        /* ===== ACTIVE POWERUPS ===== */
        #activePowerups {
            position: absolute;
            top: 120px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            padding: 10px;
            border-radius: 12px;
            max-width: 220px;
            max-height: 70vh;
            overflow-y: auto;
            font-size: 10px;
            z-index: 5;
            border: 2px solid rgba(255, 200, 0, 0.5);
            box-shadow: 0 0 20px rgba(255, 200, 0, 0.3);
            pointer-events: none;
        }

        .powerup-item {
            padding: 5px 8px;
            margin: 3px 0;
            background: rgba(255, 200, 0, 0.2);
            border-left: 3px solid #fd0;
            border-radius: 4px;
            transition: all 0.2s ease;
            border-radius: 4px;
            color: #fd0;
        }
        
        /* ===== MINIMAP ===== */
        #minimap {
            position: absolute;
            bottom: 20px;
            left: 10px;
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #0aa;
            border-radius: 8px;
            z-index: 5;
            overflow: hidden;
            pointer-events: none;
        }
        
        #minimapCanvas {
            width: 100%;
            height: 100%;
        }
        
        /* ===== CROSSHAIR ===== */
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            pointer-events: none;
            z-index: 2;
        }
        
        .crosshair-line {
            position: absolute;
            background: rgba(0, 255, 255, 0.8);
        }
        
        .crosshair-line.h {
            width: 16px;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .crosshair-line.v {
            width: 2px;
            height: 16px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .crosshair-line.left { left: 0; }
        .crosshair-line.right { right: 0; }
        .crosshair-line.top { top: 0; }
        .crosshair-line.bottom { bottom: 0; }
        
        .crosshair-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: #0ff;
            border-radius: 50%;
            box-shadow: 0 0 10px #0ff;
        }
        
        /* ===== DAMAGE FLASH ===== */
        #damageFlash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 30%, rgba(255, 0, 0, 0.5) 100%);
            pointer-events: none;
            z-index: 3;
            opacity: 0;
            transition: opacity 0.1s;
        }
        
        #damageFlash.active { opacity: 1; }
        
        /* ===== GAME MESSAGE ===== */
        #gameMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 0, 40, 0.95));
            border: 3px solid #f0a;
            padding: 25px 35px;
            border-radius: 16px;
            text-align: center;
            font-size: 18px;
            z-index: 50;
            display: none;
            box-shadow: 0 0 50px rgba(255, 0, 150, 0.4);
        }
        
        #pausedOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 99;
            display: none;
            pointer-events: none;
        }
        
        #pausedOverlay.show {
            display: block;
        }
        
        #pausedText {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 20px #0ff;
            letter-spacing: 4px;
        }
        
        #safeRoomIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -80%);
            background: linear-gradient(135deg, rgba(0, 100, 50, 0.95), rgba(0, 150, 80, 0.9));
            border: 3px solid #0f8;
            padding: 15px 30px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            z-index: 20;
            display: none;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 255, 100, 0.4);
        }
        
        #safeRoomIndicator.show {
            display: block;
        }
        
        #safeRoomIndicator .subtitle {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 5px;
        }
        
        #safeRoomIndicator .warning {
            color: #fca;
            font-size: 10px;
            margin-top: 5px;
            font-weight: bold;
        }
        
        #restartBtn {
            margin-top: 20px;
            padding: 14px 35px;
            font-size: 16px;
            background: linear-gradient(135deg, #0a8, #086);
            border: 2px solid #0fa;
            color: #fff;
            border-radius: 10px;
            cursor: pointer;
        }
        
        #restartBtn:hover {
            background: linear-gradient(135deg, #0c9, #097);
        }
        
        /* ===== HIT MARKER ===== */
        #hitMarker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 4;
            opacity: 0;
        }
        
        #hitMarker.show { opacity: 1; }
        
        .hit-line {
            position: absolute;
            background: #f00;
            box-shadow: 0 0 5px #f00;
        }
        
        .hit-line.h {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .hit-line.v {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }
        
        /* ===== CONTROLS HELP ===== */
        #controlsHelp {
            position: absolute;
            bottom: 20px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 9px;
            z-index: 5;
            border: 1px solid rgba(0, 200, 255, 0.3);
            pointer-events: none;
            max-width: 200px;
        }
        
        .control-line {
            margin: 3px 0;
            color: #aac;
        }
        
        .control-key {
            color: #0ff;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Crosshair -->
        <div class="crosshair">
            <div class="crosshair-line h left"></div>
            <div class="crosshair-line h right"></div>
            <div class="crosshair-line v top"></div>
            <div class="crosshair-line v bottom"></div>
            <div class="crosshair-dot"></div>
        </div>
        
        <!-- Hit Marker -->
        <div id="hitMarker">
            <div class="hit-line h"></div>
            <div class="hit-line v"></div>
        </div>
        
        <div id="damageFlash"></div>
        <div id="levelIndicator">LEVEL 1</div>
        <div id="powerupNotification"></div>
        <div id="warningNotification"></div>
        
        <!-- Paused Overlay -->
        <div id="pausedOverlay">
            <div id="pausedText">‚è∏Ô∏è PAUSED</div>
        </div>
        
        <!-- UI Panel -->
        <div id="ui">
            <div style="font-weight: bold; color: #0ff; margin-bottom: 6px; font-size: 13px;">üéÆ G9 CS ARENA</div>
            <div class="stat-line">
                <span class="stat-label">‚ù§Ô∏è HP</span>
                <span class="stat-value" id="health">100</span>
            </div>
            <div class="bar-container">
                <div class="bar-fill health-fill" id="healthBar" style="width: 100%"></div>
            </div>
            <div class="stat-line" style="margin-top: 6px;">
                <span class="stat-label">üî´ Ammo</span>
                <span class="stat-value" id="ammo">30</span>
            </div>
            <div class="bar-container">
                <div class="bar-fill ammo-fill" id="ammoBar" style="width: 100%"></div>
            </div>
            <div class="stat-line" style="margin-top: 6px;">
                <span class="stat-label">‚≠ê Score</span>
                <span class="stat-value" id="score">0</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">üî• Streak</span>
                <span class="stat-value" id="streak">0</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">üìä Level</span>
                <span class="stat-value" id="level">1</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">üí£ Bombs</span>
                <span class="stat-value" id="bombCount">3</span>
            </div>
        </div>
        
        <!-- Stats Panel -->
        <div id="stats">
            <div class="stat-line">
                <span class="stat-label">Enemies</span>
                <span class="stat-value" id="enemyCount">0</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">‚úì Correct</span>
                <span class="stat-value" style="color: #0f0;" id="correct">0</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">‚úó Wrong</span>
                <span class="stat-value" style="color: #f44;" id="wrong">0</span>
            </div>
        </div>
        
        <!-- Active Powerups -->
        <div id="activePowerups">
            <div style="font-weight: bold; color: #fd0; margin-bottom: 4px;">‚ö° ACTIVE</div>
            <div id="powerupsList"></div>
        </div>
        
        <!-- Minimap -->
        <div id="minimap">
            <canvas id="minimapCanvas"></canvas>
        </div>
        
        <!-- Controls Help -->
        <div id="controlsHelp">
            <div style="font-weight: bold; color: #0ff; margin-bottom: 4px;">üéÆ CONTROLS</div>
            <div class="control-line"><span class="control-key">WASD/Arrows</span> - Move</div>
            <div class="control-line"><span class="control-key">Mouse</span> - Look</div>
            <div class="control-line"><span class="control-key">Click/Space</span> - Shoot</div>
            <div class="control-line"><span class="control-key">E</span> - Bomb</div>
            <div class="control-line"><span class="control-key">Q</span> - Question</div>
            <div class="control-line"><span class="control-key">ESC</span> - Pause</div>
        </div>
        
        <!-- Safe Room Indicator -->
        <div id="safeRoomIndicator">
            üè† SAFE ROOM
            <div class="subtitle">Press Q to answer questions safely!</div>
            <div class="warning">üö´ WEAPONS DISABLED</div>
        </div>
        
        <!-- Question Modal -->
        <div id="questionModal">
            <div id="questionContainer">
                <div id="questionCategory"></div>
                <div id="questionText"></div>
                <div id="optionsContainer"></div>
                <div id="feedback"></div>
            </div>
        </div>
        
        <!-- Game Over -->
        <div id="gameMessage">
            <div id="gameOverText"></div>
            <button id="restartBtn" onclick="location.reload()">üîÑ PLAY AGAIN</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ===== IGCSE CHAPTER 7 - ALGORITHM & PROBLEM SOLVING QUESTIONS =====
        let QUESTION_POOL = [];

        // Load questions from XML file
        async function loadQuestions() {
            try {
                const response = await fetch('questions.xml');
                const xmlText = await response.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');

                const questions = xmlDoc.getElementsByTagName('question');
                QUESTION_POOL = [];

                for (let i = 0; i < questions.length; i++) {
                    const question = questions[i];
                    const text = question.getElementsByTagName('text')[0].textContent;
                    const category = question.getElementsByTagName('category')[0].textContent;
                    const options = question.getElementsByTagName('option');

                    const answers = [];
                    let correctIndex = 0;

                    for (let j = 0; j < options.length; j++) {
                        answers.push(options[j].textContent);
                        if (options[j].getAttribute('correct') === 'true') {
                            correctIndex = j;
                        }
                    }

                    QUESTION_POOL.push({
                        q: text,
                        a: answers,
                        c: correctIndex,
                        cat: category
                    });
                }

                shuffledQuestions = shuffleArray([...QUESTION_POOL]);
                console.log(`Loaded ${QUESTION_POOL.length} questions from XML`);
            } catch (error) {
                console.error('Error loading questions:', error);
            }
        }

        function shuffleArray(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        let shuffledQuestions = [];
        let questionIndex = 0;

        // ===== GAME STATE =====
        const gameState = {
            health: 100, maxHealth: 100,
            ammo: 30, maxAmmo: 60,
            bombs: 3, maxBombs: 5,
            score: 0, streak: 0,
            correct: 0, wrong: 0,
            level: 1,
            activePowerups: [],
            questionActive: false,
            paused: false,
            currentQuestion: null,
            gameOver: false,
            pauseStartTime: 0,
            inSafeRoom: false,
            safeRoomMode: false,
            // Powerup effects
            shieldActive: false,
            speedMultiplier: 1,
            damageMultiplier: 1,
            fireRateMultiplier: 1,
            magnetActive: false,
            vampireActive: false,
            piercingActive: false,
            titanMode: false,
            blackHoleActive: false,
            godBeamActive: false,
            timeFreezeActive: false,
            tornadoActive: false,
            lightningChainActive: false,
            autoAimActive: false,
            ghostModeActive: false,
            deathAuraActive: false,
            reflectActive: false,
            tripleShotActive: false,
            explosiveRoundsActive: false,
            healthRegenActive: false,
            swordAuraActive: false,

            // New movement & mobility powerups
            dashCount: 0,
            jumpMultiplier: 1,
            airControlActive: false,
            phaseWalkActive: false,

            // New combat powerups
            critChance: 0,
            homingShotsActive: false,
            chainLightningStacks: 0,
            penetrationCount: 0,
            ricochetCount: 0,
            burnStacks: 0,
            freezeShotActive: false,
            poisonStacks: 0,

            // New defense powerups
            armorStacks: 0,
            dodgeChance: 0,
            lifeStealPercent: 0,
            invincibleActive: false,
            thornsStacks: 0,

            // New resource & utility powerups
            ammoRegenStacks: 0,
            dropMultiplier: 1,
            xpMultiplier: 1,
            visionRange: 1,
            coinMagnetActive: false,

            // New special effects powerups
            vortexActive: false,
            staticFieldActive: false,
            moonGravityActive: false,
            orbitingOrbs: 0,
            cloneCount: 0,
            swarmCount: 0,
            timeSlowFactor: 1,

            // Size & scale
            sizeMultiplier: 1,

            // Synergy bonuses
            hyperactiveBonus: false,
            destructionBonus: false,
            fortressBonus: false,
            phantomBonus: false,
            absorptionBonus: false,
            berserkerBonus: false,
            marksmanBonus: false,
            thermalShockBonus: false,
            bulletHellBonus: false,
            ironcladBonus: false,
            armyBonus: false,
            stormLordBonus: false,

            bossesSpawned: []
        };

        // ===== KEYBOARD STATE =====
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            keys[e.code] = true; // Also track by code for arrow keys
            
            if (e.key.toLowerCase() === 'e') dropBomb();
            if (e.key.toLowerCase() === 'q') showQuestion(gameState.inSafeRoom);
            if (e.key === 'Escape') {
                if (!gameState.questionActive) {
                    gameState.paused = !gameState.paused;
                    document.getElementById('pausedOverlay').classList.toggle('show', gameState.paused);
                    if (!gameState.paused) animate();
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            keys[e.code] = false; // Also clear by code
        });

        // ===== MOUSE STATE =====
        let mouseLocked = false;
        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        const PI_2 = Math.PI / 2;
        
        document.addEventListener('click', () => {
            if (!mouseLocked && !gameState.questionActive) {
                renderer.domElement.requestPointerLock();
            }
            if (mouseLocked && !gameState.questionActive && !gameState.paused) {
                createProjectile();
            }
        });
        
        document.addEventListener('pointerlockchange', () => {
            mouseLocked = document.pointerLockElement === renderer.domElement;
            if (mouseLocked) {
                document.body.classList.add('pointer-locked');
            } else {
                document.body.classList.remove('pointer-locked');
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (mouseLocked) {
                const sensitivity = 0.002;
                euler.setFromQuaternion(camera.quaternion);
                euler.y -= e.movementX * sensitivity;
                euler.x -= e.movementY * sensitivity;
                euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
                camera.quaternion.setFromEuler(euler);
            }
        });

        // ===== THREE.JS SETUP =====
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue
        scene.fog = new THREE.FogExp2(0xA8D8EA, 0.012); // Light blue fog

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('gameContainer').appendChild(renderer.domElement);
        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.top = '0';
        renderer.domElement.style.left = '0';
        renderer.domElement.style.zIndex = '1';

        // ===== LIGHTING =====
        const ambientLight = new THREE.AmbientLight(0xFFFFDD, 0.7); // Warm ambient light
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xFFF8DC, 1.0); // Warm sunlight
        directionalLight.position.set(30, 50, 30);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        const pointLight1 = new THREE.PointLight(0xFFE4B5, 0.4, 60); // Soft warm light
        pointLight1.position.set(-25, 10, -25);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xFFF8DC, 0.4, 60); // Soft warm light
        pointLight2.position.set(25, 10, 25);
        scene.add(pointLight2);

        // ===== LEVEL GENERATION =====
        const levelObjects = [];
        const traps = [];
        const ARENA_SIZE = 70;
        
        const SAFE_ROOM = {
            x: -ARENA_SIZE + 20,
            z: 0,
            width: 18,
            depth: 18,
            height: 8
        };

        let gridHelper;

        function generateLevel(level) {
            levelObjects.forEach(obj => scene.remove(obj));
            levelObjects.length = 0;
            traps.forEach(t => { scene.remove(t.mesh); scene.remove(t.spikes); });
            traps.length = 0;

            const groundGeom = new THREE.PlaneGeometry(ARENA_SIZE * 2, ARENA_SIZE * 2, 40, 40);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x3A7D44, // Grass green
                roughness: 0.9,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeom, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            levelObjects.push(ground);

            if (gridHelper) scene.remove(gridHelper);
            gridHelper = new THREE.GridHelper(ARENA_SIZE * 2, 60, 0x8B7355, 0x556B2F); // Brown and olive green paths
            gridHelper.position.y = 0.05;
            scene.add(gridHelper);
            levelObjects.push(gridHelper);

            const wallMat = new THREE.MeshStandardMaterial({ color: 0x2D5016, emissive: 0x1A3010, emissiveIntensity: 0.2, metalness: 0.1, roughness: 0.9 }); // Dark green hedge
            [
                { x: 0, z: -ARENA_SIZE, ry: 0 },
                { x: 0, z: ARENA_SIZE, ry: 0 },
                { x: -ARENA_SIZE, z: 0, ry: Math.PI/2 },
                { x: ARENA_SIZE, z: 0, ry: Math.PI/2 }
            ].forEach(p => {
                const wall = new THREE.Mesh(new THREE.BoxGeometry(ARENA_SIZE * 2, 12, 2), wallMat);
                wall.position.set(p.x, 6, p.z);
                wall.rotation.y = p.ry;
                wall.castShadow = true;
                scene.add(wall);
                levelObjects.push(wall);
            });

            const obsMat = new THREE.MeshStandardMaterial({ color: 0x4A7C59, roughness: 0.9, metalness: 0.1 }); // Tree/bush green
            const obsEmissive = new THREE.MeshStandardMaterial({ color: 0x2F4F2F, emissive: 0x228B22, emissiveIntensity: 0.3 }); // Dark green trim
            
            for (let i = 0; i < 6 + level * 2; i++) {
                const s = 3 + Math.random() * 4;
                const h = 4 + Math.random() * 8;
                const geom = [
                    new THREE.BoxGeometry(s, h, s),
                    new THREE.CylinderGeometry(s/2, s/2, h, 8),
                    new THREE.ConeGeometry(s/2, h, 6)
                ][Math.floor(Math.random() * 3)];
                
                const obs = new THREE.Mesh(geom, obsMat);
                obs.position.set((Math.random() - 0.5) * (ARENA_SIZE - 20), h/2, (Math.random() - 0.5) * (ARENA_SIZE - 20));
                
                if (Math.random() > 0.5) {
                    const trim = new THREE.Mesh(new THREE.BoxGeometry(s + 0.1, 0.2, s + 0.1), obsEmissive);
                    trim.position.y = Math.random() * h/2;
                    obs.add(trim);
                }

                obs.castShadow = true;
                scene.add(obs);
                levelObjects.push(obs);
            }

            for (let i = 0; i < Math.min(level + 1, 6); i++) createTrap();

            const pillarMat = new THREE.MeshStandardMaterial({ color: 0xD2691E, emissive: 0x8B4513, emissiveIntensity: 0.3, transparent: false, opacity: 1.0 }); // Brown garden posts
            for (let i = 0; i < 6; i++) {
                const pillar = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 20, 8), pillarMat);
                const angle = (i / 6) * Math.PI * 2;
                pillar.position.set(Math.cos(angle) * (ARENA_SIZE - 15), 10, Math.sin(angle) * (ARENA_SIZE - 15));
                pillar.castShadow = true;
                scene.add(pillar);
                levelObjects.push(pillar);
            }
            
            createSafeRoom();
            createDust();
        }
        
        let dustSystem;
        function createDust() {
            if (dustSystem) scene.remove(dustSystem);
            const geom = new THREE.BufferGeometry();
            const counts = 300; // Reduced from 1000
            const positions = new Float32Array(counts * 3);
            for(let i=0; i<counts*3; i+=3) {
                positions[i] = (Math.random() - 0.5) * ARENA_SIZE * 2;
                positions[i+1] = Math.random() * 20;
                positions[i+2] = (Math.random() - 0.5) * ARENA_SIZE * 2;
            }
            geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0xFFFACD, size: 0.15, transparent: true, opacity: 0.4 }); // Soft yellow pollen/fireflies
            dustSystem = new THREE.Points(geom, mat);
            scene.add(dustSystem);
        }

        function createSafeRoom() {
            const sr = SAFE_ROOM;

            const floorMat = new THREE.MeshStandardMaterial({
                color: 0x8B7355, // Wooden deck
                emissive: 0x5D4E37,
                emissiveIntensity: 0.1,
                roughness: 0.8
            });
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(sr.width, sr.depth), floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(sr.x, 0.1, sr.z);
            scene.add(floor);
            levelObjects.push(floor);

            const wallMat = new THREE.MeshStandardMaterial({
                color: 0xF5DEB3, // Light wood/beige
                emissive: 0xD2B48C,
                emissiveIntensity: 0.2,
                transparent: true,
                opacity: 0.5
            });
            
            const backWall = new THREE.Mesh(new THREE.BoxGeometry(sr.width, sr.height, 0.5), wallMat);
            backWall.position.set(sr.x, sr.height / 2, sr.z - sr.depth / 2);
            scene.add(backWall);
            levelObjects.push(backWall);
            
            const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, sr.height, sr.depth), wallMat);
            leftWall.position.set(sr.x - sr.width / 2, sr.height / 2, sr.z);
            scene.add(leftWall);
            levelObjects.push(leftWall);
            
            const rightWallTop = new THREE.Mesh(new THREE.BoxGeometry(0.5, sr.height - 4, sr.depth), wallMat);
            rightWallTop.position.set(sr.x + sr.width / 2, sr.height - 2, sr.z);
            scene.add(rightWallTop);
            levelObjects.push(rightWallTop);
            
            const frontWallLeft = new THREE.Mesh(new THREE.BoxGeometry((sr.width - 6) / 2, sr.height, 0.5), wallMat);
            frontWallLeft.position.set(sr.x - sr.width / 4 - 1.5, sr.height / 2, sr.z + sr.depth / 2);
            scene.add(frontWallLeft);
            levelObjects.push(frontWallLeft);
            
            const frontWallRight = new THREE.Mesh(new THREE.BoxGeometry((sr.width - 6) / 2, sr.height, 0.5), wallMat);
            frontWallRight.position.set(sr.x + sr.width / 4 + 1.5, sr.height / 2, sr.z + sr.depth / 2);
            scene.add(frontWallRight);
            levelObjects.push(frontWallRight);
            
            const signMat = new THREE.MeshStandardMaterial({
                color: 0xFFFFE0, // Light yellow sign
                emissive: 0xFFFACD,
                emissiveIntensity: 0.6
            });
            const sign = new THREE.Mesh(new THREE.BoxGeometry(4, 1, 0.2), signMat);
            sign.position.set(sr.x, sr.height + 1, sr.z + sr.depth / 2);
            scene.add(sign);
            levelObjects.push(sign);

            const safeLight = new THREE.PointLight(0xFFF8DC, 0.8, 25); // Warm garden light
            safeLight.position.set(sr.x, 5, sr.z);
            scene.add(safeLight);
            levelObjects.push(safeLight);
        }

        function createTrap() {
            const trapMat = new THREE.MeshBasicMaterial({ color: 0xff0044, transparent: true, opacity: 0.4 });
            const trap = new THREE.Mesh(new THREE.CircleGeometry(3.5, 16), trapMat);
            trap.rotation.x = -Math.PI / 2;
            trap.position.set((Math.random() - 0.5) * (ARENA_SIZE - 25), 0.1, (Math.random() - 0.5) * (ARENA_SIZE - 25));
            
            const spikes = new THREE.Group();
            const spikeMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xaa0000, emissiveIntensity: 0.5 });
            for (let i = 0; i < 6; i++) {
                const spike = new THREE.Mesh(new THREE.ConeGeometry(0.25, 1.2, 4), spikeMat);
                const angle = (i / 6) * Math.PI * 2;
                spike.position.set(Math.cos(angle) * 1.8, 0, Math.sin(angle) * 1.8);
                spikes.add(spike);
            }
            spikes.position.copy(trap.position);
            spikes.position.y = -1;
            
            scene.add(trap);
            scene.add(spikes);
            traps.push({ mesh: trap, spikes, active: false, timer: 0, cooldown: 0 });
        }

        function updateTraps() {
            traps.forEach(trap => {
                const dist = Math.sqrt(
                    Math.pow(camera.position.x - trap.mesh.position.x, 2) +
                    Math.pow(camera.position.z - trap.mesh.position.z, 2)
                );
                trap.timer++;
                
                if (dist < 3.5 && trap.cooldown <= 0) {
                    trap.active = true;
                    trap.cooldown = 180;
                }

                if (trap.active) {
                    trap.spikes.position.y = Math.min(trap.spikes.position.y + 0.25, 0.6);
                    if (trap.spikes.position.y >= 0.5 && dist < 3.5 && !gameState.shieldActive && !gameState.titanMode) {
                        gameState.health -= 0.8;
                        showDamageFlash();
                    }
                    if (trap.timer % 50 === 0) trap.active = false;
                } else {
                    trap.spikes.position.y = Math.max(trap.spikes.position.y - 0.15, -1);
                }

                if (trap.cooldown > 0) trap.cooldown--;
                trap.mesh.material.opacity = 0.3 + Math.sin(trap.timer * 0.1) * 0.15;
            });
        }

        // ===== ENEMY SYSTEM =====
        const enemies = [];
        const ENEMY_TYPES = {
            BASIC: { name: 'Basic', color: 0xff3333, health: 15, speed: 0.035, damage: 2, size: { w: 1.2, h: 2.2, d: 1.2 }, score: 100, hitRadius: 1.8 },
            FAST: { name: 'Fast', color: 0xffff00, health: 8, speed: 0.08, damage: 1, size: { w: 0.8, h: 1.6, d: 0.8 }, score: 150, hitRadius: 1.3 },
            TANK: { name: 'Tank', color: 0x8844ff, health: 45, speed: 0.018, damage: 6, size: { w: 2, h: 2.8, d: 2 }, score: 250, hitRadius: 2.5 },
            RANGED: { name: 'Ranged', color: 0x00ff88, health: 12, speed: 0.022, damage: 4, size: { w: 1.1, h: 2.4, d: 1.1 }, score: 200, ranged: true, fireRate: 100, hitRadius: 1.7 },
            KAMIKAZE: { name: 'Kamikaze', color: 0xff0000, health: 5, speed: 0.12, damage: 25, size: { w: 0.7, h: 0.7, d: 0.7 }, score: 300, kamikaze: true, hitRadius: 1.0 },
            SNIPER: { name: 'Sniper', color: 0x00ccff, health: 10, speed: 0.015, damage: 8, size: { w: 0.9, h: 2.5, d: 0.9 }, score: 350, ranged: true, fireRate: 180, hitRadius: 1.5, longRange: true },
            HEALER: { name: 'Healer', color: 0x00ff00, health: 20, speed: 0.03, damage: 1, size: { w: 1.3, h: 2.3, d: 1.3 }, score: 400, hitRadius: 2.0, healer: true, healRate: 120, healAmount: 3 },
            SPLITTER: { name: 'Splitter', color: 0xff8800, health: 18, speed: 0.04, damage: 3, size: { w: 1.5, h: 2.0, d: 1.5 }, score: 450, hitRadius: 2.0, splitter: true },
            TELEPORTER: { name: 'Teleporter', color: 0xcc00ff, health: 12, speed: 0.045, damage: 4, size: { w: 1.0, h: 2.1, d: 1.0 }, score: 500, hitRadius: 1.6, teleporter: true, teleportRate: 150 },
            BOSS: { name: 'BOSS', color: 0xff00ff, health: 200, speed: 0.025, damage: 15, size: { w: 4, h: 5, d: 4 }, score: 2000, hitRadius: 5, isBoss: true, fireRate: 60 }
        };

        function createEnemy(type = null) {
            if (!type) {
                const rand = Math.random();
                const lvl = gameState.level;
                if (rand < 0.25) type = ENEMY_TYPES.BASIC;
                else if (rand < 0.40) type = ENEMY_TYPES.FAST;
                else if (rand < 0.52 && lvl >= 2) type = ENEMY_TYPES.TANK;
                else if (rand < 0.64 && lvl >= 2) type = ENEMY_TYPES.RANGED;
                else if (rand < 0.72 && lvl >= 3) type = ENEMY_TYPES.KAMIKAZE;
                else if (rand < 0.80 && lvl >= 3) type = ENEMY_TYPES.SNIPER;
                else if (rand < 0.87 && lvl >= 4) type = ENEMY_TYPES.HEALER;
                else if (rand < 0.93 && lvl >= 4) type = ENEMY_TYPES.SPLITTER;
                else if (lvl >= 5) type = ENEMY_TYPES.TELEPORTER;
                else type = ENEMY_TYPES.BASIC;
            }

            const geom = type.kamikaze ? new THREE.SphereGeometry(type.size.w/2, 16, 16) : new THREE.BoxGeometry(type.size.w, type.size.h, type.size.d);
            const mat = new THREE.MeshStandardMaterial({ 
                color: type.color, 
                emissive: type.color, 
                emissiveIntensity: type.isBoss ? 0.8 : 0.4
            });
            const enemy = new THREE.Mesh(geom, mat);
            enemy.castShadow = true;

            const angle = Math.random() * Math.PI * 2;
            enemy.position.set(Math.cos(angle) * (ARENA_SIZE - 8), type.size.h / 2, Math.sin(angle) * (ARENA_SIZE - 8));

            // Scale difficulty based on level
            const levelScaling = 1 + (gameState.level - 1) * 0.15; // 15% increase per level
            const healthScaling = 1 + (gameState.level - 1) * 0.2;  // 20% health increase per level
            const speedScaling = Math.min(1 + (gameState.level - 1) * 0.08, 2); // 8% speed increase, max 2x

            enemy.enemyType = type;
            enemy.health = type.health * healthScaling;
            enemy.maxHealth = type.health * healthScaling;
            enemy.speed = type.speed * speedScaling;
            enemy.damage = type.damage * levelScaling;
            enemy.hitRadius = type.hitRadius;
            enemy.hasDropped = false;
            enemy.fireTimer = 0;
            enemy.healTimer = 0;
            enemy.teleportTimer = 0;

            const hbMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const healthBar = new THREE.Mesh(new THREE.PlaneGeometry(type.isBoss ? 5 : 2.5, type.isBoss ? 0.4 : 0.25), hbMat);
            healthBar.position.y = type.size.h / 2 + (type.isBoss ? 1.2 : 0.6);
            enemy.add(healthBar);
            enemy.healthBar = healthBar;
            
            // Boss crown
            if (type.isBoss) {
                const crownMat = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1 });
                const crown = new THREE.Mesh(new THREE.ConeGeometry(1, 2, 6), crownMat);
                crown.position.y = type.size.h / 2 + 2;
                enemy.add(crown);
                enemy.crown = crown;
            }

            enemy.boundingBox = new THREE.Box3();

            scene.add(enemy);
            enemies.push(enemy);
        }

        function createMiniEnemy(position, parentType) {
            const miniType = {
                ...ENEMY_TYPES.FAST,
                health: 5,
                size: { w: 0.6, h: 1.2, d: 0.6 },
                score: 75,
                hitRadius: 1.0,
                color: parentType.color
            };
            const geom = new THREE.BoxGeometry(miniType.size.w, miniType.size.h, miniType.size.d);
            const mat = new THREE.MeshStandardMaterial({
                color: miniType.color,
                emissive: miniType.color,
                emissiveIntensity: 0.4
            });
            const enemy = new THREE.Mesh(geom, mat);
            enemy.castShadow = true;

            const offset = new THREE.Vector3((Math.random()-0.5)*3, 0, (Math.random()-0.5)*3);
            enemy.position.copy(position).add(offset);
            enemy.position.y = miniType.size.h / 2;

            enemy.enemyType = miniType;
            enemy.health = miniType.health;
            enemy.maxHealth = miniType.health;
            enemy.speed = miniType.speed;
            enemy.damage = miniType.damage;
            enemy.hitRadius = miniType.hitRadius;
            enemy.hasDropped = false;
            enemy.fireTimer = 0;
            enemy.healTimer = 0;
            enemy.teleportTimer = 0;
            enemy.isSplit = true;

            const hbMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const healthBar = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 0.2), hbMat);
            healthBar.position.y = miniType.size.h / 2 + 0.4;
            enemy.add(healthBar);
            enemy.healthBar = healthBar;
            enemy.boundingBox = new THREE.Box3();

            scene.add(enemy);
            enemies.push(enemy);
            return enemy;
        }

        const enemyProjectiles = [];

        function updateEnemies() {
            enemies.forEach((enemy, idx) => {
                enemy.boundingBox.setFromObject(enemy);
                
                // Titan Mode Stomp
                if (gameState.titanMode) {
                    const distToPlayer = enemy.position.distanceTo(new THREE.Vector3(camera.position.x, enemy.position.y, camera.position.z));
                    if (distToPlayer < 4) {
                        enemy.health = 0;
                        createParticleBurst(enemy.position, 0xff0000, 8);
                    }
                }
                
                // Death Aura - damages enemies within 10 units
                if (gameState.deathAuraActive) {
                    const distToPlayer = enemy.position.distanceTo(camera.position);
                    if (distToPlayer < 10) {
                        enemy.health -= 0.5;
                        if (Math.random() > 0.95) createParticleBurst(enemy.position, 0x880088, 3);
                    }
                }

                if (enemy.health <= 0) {
                    createExplosion(enemy.position, enemy.enemyType.color, enemy.enemyType.isBoss ? 20 : 12);

                    // Splitter: spawns 2 smaller enemies when killed
                    if (enemy.enemyType.splitter && !enemy.isSplit) {
                        for (let i = 0; i < 2; i++) {
                            setTimeout(() => {
                                const miniEnemy = createMiniEnemy(enemy.position.clone(), enemy.enemyType);
                            }, i * 100);
                        }
                    }

                    if (!enemy.hasDropped) {
                        const dropChance = enemy.enemyType.isBoss ? 1 : 0.6;
                        if (Math.random() > (1 - dropChance)) spawnPowerup(enemy.position);
                        if (enemy.enemyType.isBoss) {
                            // Boss drops multiple powerups
                            for (let i = 0; i < 3; i++) {
                                setTimeout(() => spawnPowerup(enemy.position.clone().add(new THREE.Vector3((Math.random()-0.5)*5, 0, (Math.random()-0.5)*5))), i * 200);
                            }
                        }
                        enemy.hasDropped = true;
                    }
                    scene.remove(enemy);
                    enemies.splice(idx, 1);
                    gameState.score += enemy.enemyType.score * gameState.damageMultiplier;

                    if (gameState.vampireActive) {
                        gameState.health = Math.min(gameState.maxHealth, gameState.health + 5);
                    }
                    return;
                }

                const hp = enemy.health / enemy.maxHealth;
                enemy.healthBar.scale.x = hp;
                enemy.healthBar.material.color.setHex(hp > 0.5 ? 0x00ff00 : (hp > 0.25 ? 0xffff00 : 0xff0000));
                enemy.healthBar.lookAt(camera.position);

                // Time Freeze - enemies don't move
                if (gameState.timeFreezeActive) {
                    enemy.material.emissiveIntensity = 0.1;
                    return;
                }
                enemy.material.emissiveIntensity = enemy.enemyType.isBoss ? 0.8 : 0.4;

                const dir = new THREE.Vector3().subVectors(camera.position, enemy.position);
                dir.y = 0;
                
                const nextPos = enemy.position.clone().addScaledVector(dir.clone().normalize(), enemy.speed);
                const inSafeZone = isInSafeRoom(nextPos);
                
                // Black Hole Pull
                if (gameState.blackHoleActive && blackHoleMesh) {
                    const pullDir = new THREE.Vector3().subVectors(blackHoleMesh.position, enemy.position).normalize();
                    enemy.position.addScaledVector(pullDir, 0.3);
                    
                    if (enemy.position.distanceTo(blackHoleMesh.position) < 2) {
                        enemy.health -= 5;
                    }
                }
                
                // Tornado Pull
                if (gameState.tornadoActive && tornadoMesh) {
                    const pullDir = new THREE.Vector3().subVectors(tornadoMesh.position, enemy.position).normalize();
                    enemy.position.addScaledVector(pullDir, 0.2);
                    enemy.position.y += Math.sin(Date.now() * 0.01) * 0.1; // Lift up
                    
                    if (enemy.position.distanceTo(tornadoMesh.position) < 4) {
                        enemy.health -= 0.3;
                        enemy.rotation.y += 0.2; // Spin them
                    }
                }

                // Healer behavior: heals nearby enemies
                if (enemy.enemyType.healer) {
                    enemy.healTimer++;
                    if (enemy.healTimer >= enemy.enemyType.healRate) {
                        enemy.healTimer = 0;
                        enemies.forEach(otherEnemy => {
                            if (otherEnemy !== enemy && enemy.position.distanceTo(otherEnemy.position) < 15) {
                                otherEnemy.health = Math.min(otherEnemy.maxHealth, otherEnemy.health + enemy.enemyType.healAmount);
                                createParticleBurst(otherEnemy.position, 0x00ff00, 3);
                            }
                        });
                    }
                    // Healers try to stay at medium distance
                    const dist = dir.length();
                    if (dist < 10) dir.negate();
                    else if (dist > 18 && !inSafeZone) {
                        dir.normalize();
                        enemy.position.addScaledVector(dir, enemy.speed);
                    }
                } else if (enemy.enemyType.teleporter) {
                    // Teleporter: randomly teleports around the player
                    enemy.teleportTimer++;
                    if (enemy.teleportTimer >= enemy.enemyType.teleportRate) {
                        enemy.teleportTimer = 0;
                        createParticleBurst(enemy.position, enemy.enemyType.color, 15);
                        const angle = Math.random() * Math.PI * 2;
                        const dist = 8 + Math.random() * 10;
                        enemy.position.set(
                            camera.position.x + Math.cos(angle) * dist,
                            enemy.enemyType.size.h / 2,
                            camera.position.z + Math.sin(angle) * dist
                        );
                        createParticleBurst(enemy.position, enemy.enemyType.color, 15);
                    } else {
                        if (!inSafeZone) {
                            dir.normalize();
                            enemy.position.addScaledVector(dir, enemy.speed);
                        }
                    }
                } else if (enemy.enemyType.ranged || enemy.enemyType.isBoss || enemy.enemyType.longRange) {
                    const dist = dir.length();
                    const minDist = enemy.enemyType.longRange ? 20 : 12;
                    const maxDist = enemy.enemyType.longRange ? 35 : 20;
                    if (dist < minDist) dir.negate();
                    else if (dist > maxDist && !inSafeZone) {
                        dir.normalize();
                        enemy.position.addScaledVector(dir, enemy.speed);
                    }
                    enemy.fireTimer++;
                    if (enemy.fireTimer >= enemy.enemyType.fireRate && !gameState.inSafeRoom) {
                        enemy.fireTimer = 0;
                        createEnemyProjectile(enemy.position.clone(), camera.position.clone());
                        // Boss fires 3 projectiles
                        if (enemy.enemyType.isBoss) {
                            setTimeout(() => createEnemyProjectile(enemy.position.clone(), camera.position.clone()), 100);
                            setTimeout(() => createEnemyProjectile(enemy.position.clone(), camera.position.clone()), 200);
                        }
                    }
                } else if (enemy.enemyType.kamikaze) {
                    if (!inSafeZone) {
                        dir.normalize();
                        enemy.position.addScaledVector(dir, enemy.speed);
                        enemy.material.emissiveIntensity = 0.5 + Math.sin(Date.now() * 0.02) * 0.5;
                    }
                } else {
                    if (!inSafeZone) {
                        dir.normalize();
                        enemy.position.addScaledVector(dir, enemy.speed);
                    } else {
                        const avoidDir = new THREE.Vector3(enemy.position.x - SAFE_ROOM.x, 0, enemy.position.z - SAFE_ROOM.z).normalize();
                        enemy.position.addScaledVector(avoidDir, enemy.speed * 0.5);
                    }
                }

                if (!gameState.inSafeRoom && enemy.position.distanceTo(camera.position) < enemy.hitRadius + 0.8) {
                    if (enemy.enemyType.kamikaze) {
                        enemy.health = 0;
                        createExplosion(enemy.position, 0xff0000, 25);
                        if (!gameState.shieldActive && !gameState.titanMode && !gameState.ghostModeActive) {
                            gameState.health -= enemy.damage;
                            showDamageFlash();
                        }
                    } else if (!gameState.shieldActive && !gameState.titanMode && !gameState.ghostModeActive) {
                        gameState.health -= enemy.damage * 0.08;
                        showDamageFlash();
                    }
                    
                    if (gameState.reflectActive) enemy.health -= 3;
                }

                enemy.rotation.y += enemy.enemyType.isBoss ? 0.02 : 0.015;
                if (enemy.crown) enemy.crown.rotation.y += 0.1;
            });

            enemyProjectiles.forEach((proj, idx) => {
                proj.position.add(proj.velocity);
                proj.life--;

                if (proj.life <= 0) {
                    scene.remove(proj);
                    enemyProjectiles.splice(idx, 1);
                    return;
                }

                if (isInSafeRoom(proj.position)) {
                    createParticleBurst(proj.position, 0x00ff88, 8);
                    scene.remove(proj);
                    enemyProjectiles.splice(idx, 1);
                    return;
                }

                if (proj.position.distanceTo(camera.position) < 1.2) {
                    if (!gameState.shieldActive && !gameState.inSafeRoom && !gameState.titanMode) {
                        gameState.health -= 6;
                        showDamageFlash();
                    }
                    if (gameState.reflectActive) {
                        proj.velocity.negate();
                        proj.life = 100;
                        proj.reflected = true;
                    } else {
                        scene.remove(proj);
                        enemyProjectiles.splice(idx, 1);
                    }
                }
                
                if (proj.reflected) {
                    enemies.forEach(enemy => {
                        if (proj.position.distanceTo(enemy.position) < enemy.hitRadius) {
                            enemy.health -= 10;
                            scene.remove(proj);
                            enemyProjectiles.splice(idx, 1);
                        }
                    });
                }
            });

            const maxEnemies = 4 + gameState.level * 2;
            if (enemies.length < maxEnemies && Math.random() > 0.985) {
                createEnemy();
            }
            
            // Spawn boss at levels 5 and 10
            const bossExists = enemies.some(e => e.enemyType.isBoss);
            if (!bossExists && (gameState.level === 5 || gameState.level === 10) && !gameState.bossesSpawned.includes(gameState.level)) {
                createEnemy(ENEMY_TYPES.BOSS);
                gameState.bossesSpawned.push(gameState.level);
                showPowerupNotification(`‚ö†Ô∏è LEVEL ${gameState.level} BOSS BATTLE!`);
            }
        }
        
        function isInSafeRoom(pos) {
            const sr = SAFE_ROOM;
            return pos.x > sr.x - sr.width / 2 && 
                   pos.x < sr.x + sr.width / 2 && 
                   pos.z > sr.z - sr.depth / 2 && 
                   pos.z < sr.z + sr.depth / 2;
        }
        
        function updateSafeRoomStatus() {
            const wasInSafeRoom = gameState.inSafeRoom;
            gameState.inSafeRoom = isInSafeRoom(camera.position);
            
            const indicator = document.getElementById('safeRoomIndicator');
            
            if (gameState.inSafeRoom) {
                indicator.classList.add('show');
            } else {
                indicator.classList.remove('show');
            }
        }

        function createEnemyProjectile(from, to) {
            const proj = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            proj.position.copy(from);
            proj.position.y = 1.5;
            proj.velocity = new THREE.Vector3().subVectors(to, from).normalize().multiplyScalar(0.35);
            proj.life = 150;
            proj.reflected = false;
            scene.add(proj);
            enemyProjectiles.push(proj);
        }

        // ===== POWERUP SYSTEM =====
        const powerupObjects = [];
        const POWERUP_TYPES = [
            // Essentials
            { name: "‚ù§Ô∏è Health +40", color: 0xff4444, rarity: 1, effect: () => { gameState.health = Math.min(gameState.maxHealth, gameState.health + 40); } },
            { name: "üî´ Ammo +20", color: 0xffff00, rarity: 1, effect: () => { gameState.ammo = Math.min(gameState.maxAmmo, gameState.ammo + 20); } },
            
            // Defense
            { name: "üõ°Ô∏è Shield", color: 0x4488ff, rarity: 0.6, duration: 10000, effect: () => { 
                gameState.shieldActive = true; addTimedPowerup("üõ°Ô∏è Shield", 10000, () => { gameState.shieldActive = false; }); }},
            
            // CRAZY POWERUPS
            { name: "üåå BLACK HOLE", color: 0xaa00ff, rarity: 0.15, duration: 8000, effect: () => {
                activateBlackHole();
            }},
            { name: "üî± TITAN MODE", color: 0xffaa00, rarity: 0.1, duration: 15000, effect: () => {
                gameState.titanMode = true;
                camera.position.y = 8;
                addTimedPowerup("üî± TITAN", 15000, () => { 
                    gameState.titanMode = false; 
                    camera.position.y = 3; 
                });
            }},
            { name: "‚ú® GOD BEAM", color: 0x00ffff, rarity: 0.2, duration: 6000, effect: () => {
                gameState.godBeamActive = true;
                addTimedPowerup("‚ú® BEAM", 6000, () => { gameState.godBeamActive = false; });
            }},
            { name: "‚è∞ TIME FREEZE", color: 0x88ffff, rarity: 0.15, duration: 8000, effect: () => {
                gameState.timeFreezeActive = true;
                addTimedPowerup("‚è∞ FREEZE", 8000, () => { gameState.timeFreezeActive = false; });
            }},
            { name: "üå™Ô∏è TORNADO", color: 0xaaffaa, rarity: 0.12, duration: 10000, effect: () => {
                activateTornado();
            }},
            { name: "‚ö° LIGHTNING CHAIN", color: 0xffff88, rarity: 0.18, duration: 12000, effect: () => {
                gameState.lightningChainActive = true;
                addTimedPowerup("‚ö° CHAIN", 12000, () => { gameState.lightningChainActive = false; });
            }},
            { name: "üéØ AUTO-AIM", color: 0xff88ff, rarity: 0.2, duration: 15000, effect: () => {
                gameState.autoAimActive = true;
                addTimedPowerup("üéØ AIM", 15000, () => { gameState.autoAimActive = false; });
            }},
            { name: "üëª GHOST MODE", color: 0xccccff, rarity: 0.15, duration: 10000, effect: () => {
                gameState.ghostModeActive = true;
                addTimedPowerup("üëª GHOST", 10000, () => { gameState.ghostModeActive = false; });
            }},
            { name: "üíÄ DEATH AURA", color: 0x880088, rarity: 0.1, duration: 8000, effect: () => {
                gameState.deathAuraActive = true;
                addTimedPowerup("üíÄ AURA", 8000, () => { gameState.deathAuraActive = false; });
            }},
            { name: "üöÄ ORBITAL STRIKE", color: 0xff0088, rarity: 0.08, effect: () => {
                activateOrbitalStrike();
            }},
            
            // Enhanced Offense - NOW STACKABLE!
            { name: "‚ö° Speed Boost", color: 0x00ffff, rarity: 0.7, duration: 12000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "‚ö° Speed")?.stacks || 0) + 1;
                gameState.speedMultiplier = 1 + (stacks * 0.5); // Each stack adds 0.5x speed
                addTimedPowerup("‚ö° Speed", 12000, () => {
                    const remaining = gameState.activePowerups.find(p => p.name === "‚ö° Speed")?.stacks || 0;
                    gameState.speedMultiplier = Math.max(1, 1 + (remaining * 0.5));
                }, true);
            }},
            { name: "üí• Damage Boost", color: 0xff8800, rarity: 0.7, duration: 15000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "üí• Damage")?.stacks || 0) + 1;
                gameState.damageMultiplier = 1 + (stacks * 0.5); // Each stack adds 0.5x damage
                addTimedPowerup("üí• Damage", 15000, () => {
                    const remaining = gameState.activePowerups.find(p => p.name === "üí• Damage")?.stacks || 0;
                    gameState.damageMultiplier = Math.max(1, 1 + (remaining * 0.5));
                }, true);
            }},
            { name: "üî• Rapid Fire", color: 0xff4400, rarity: 0.6, duration: 10000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "üî• Rapid")?.stacks || 0) + 1;
                gameState.fireRateMultiplier = 1 + (stacks * 1.5); // Each stack adds 1.5x fire rate
                addTimedPowerup("üî• Rapid", 10000, () => {
                    const remaining = gameState.activePowerups.find(p => p.name === "üî• Rapid")?.stacks || 0;
                    gameState.fireRateMultiplier = Math.max(1, 1 + (remaining * 1.5));
                }, true);
            }},
            
            // Special
            { name: "üß≤ Magnet", color: 0xffdd00, rarity: 0.5, duration: 15000, effect: () => {
                gameState.magnetActive = true; addTimedPowerup("üß≤ Magnet", 15000, () => { gameState.magnetActive = false; }); }},
            { name: "üßõ Vampire", color: 0xaa0055, rarity: 0.4, duration: 12000, effect: () => {
                gameState.vampireActive = true; addTimedPowerup("üßõ Vampire", 12000, () => { gameState.vampireActive = false; }); }},
            { name: "üí£ Bomb +2", color: 0xff6600, rarity: 0.6, effect: () => { gameState.bombs = Math.min(gameState.maxBombs, gameState.bombs + 2); } },

            // New Powerups
            { name: "‚ò¢Ô∏è NUKE", color: 0xff0000, rarity: 0.08, effect: () => {
                activateNuke();
            }},
            { name: "üî∞ Reflect Shield", color: 0x00ddff, rarity: 0.3, duration: 12000, effect: () => {
                gameState.reflectActive = true; addTimedPowerup("üî∞ Reflect", 12000, () => { gameState.reflectActive = false; });
            }},
            { name: "üî± Triple Shot", color: 0xff00aa, rarity: 0.4, duration: 15000, effect: () => {
                gameState.tripleShotActive = true; addTimedPowerup("üî± Triple", 15000, () => { gameState.tripleShotActive = false; });
            }},
            { name: "üí• Explosive Rounds", color: 0xff6600, rarity: 0.35, duration: 12000, effect: () => {
                gameState.explosiveRoundsActive = true; addTimedPowerup("üí• Explosive", 12000, () => { gameState.explosiveRoundsActive = false; });
            }},
            { name: "üíö Health Regen", color: 0x00ff66, rarity: 0.45, duration: 20000, effect: () => {
                gameState.healthRegenActive = true; addTimedPowerup("üíö Regen", 20000, () => { gameState.healthRegenActive = false; });
            }},
            { name: "‚öîÔ∏è Sword Aura", color: 0xffaa00, rarity: 0.25, duration: 10000, effect: () => {
                gameState.swordAuraActive = true; addTimedPowerup("‚öîÔ∏è Sword", 10000, () => { gameState.swordAuraActive = false; });
            }},

            // ===== MASSIVE NEW POWERUP EXPANSION =====

            // Movement & Mobility
            { name: "üåÄ Dash", color: 0x00ddff, rarity: 0.5, duration: 15000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "üåÄ Dash")?.stacks || 0) + 1;
                gameState.dashCount = stacks;
                addTimedPowerup("üåÄ Dash", 15000, () => {
                    gameState.dashCount = Math.max(0, (gameState.activePowerups.find(p => p.name === "üåÄ Dash")?.stacks || 0));
                }, true);
            }},
            { name: "ü¶ò Jump Boost", color: 0xff99ff, rarity: 0.4, duration: 12000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "ü¶ò Jump")?.stacks || 0) + 1;
                gameState.jumpMultiplier = 1 + (stacks * 0.4);
                addTimedPowerup("ü¶ò Jump", 12000, () => {
                    const remaining = gameState.activePowerups.find(p => p.name === "ü¶ò Jump")?.stacks || 0;
                    gameState.jumpMultiplier = Math.max(1, 1 + (remaining * 0.4));
                }, true);
            }},
            { name: "üí® Air Control", color: 0xbbffbb, rarity: 0.35, duration: 18000, effect: () => {
                gameState.airControlActive = true; addTimedPowerup("üí® Air", 18000, () => { gameState.airControlActive = false; });
            }},
            { name: "üåä Phase Walk", color: 0x5599ff, rarity: 0.25, duration: 10000, effect: () => {
                gameState.phaseWalkActive = true; addTimedPowerup("üåä Phase", 10000, () => { gameState.phaseWalkActive = false; });
            }},

            // Combat Enhancements
            { name: "üéØ Precision", color: 0xffaa88, rarity: 0.4, duration: 15000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "üéØ Precision")?.stacks || 0) + 1;
                gameState.critChance = Math.min(0.8, 0.1 + (stacks * 0.15)); // 15% crit per stack, max 80%
                addTimedPowerup("üéØ Precision", 15000, () => {
                    const remaining = gameState.activePowerups.find(p => p.name === "üéØ Precision")?.stacks || 0;
                    gameState.critChance = Math.max(0, 0.1 + (remaining * 0.15));
                }, true);
            }},
            { name: "üîÆ Homing Shots", color: 0xaa88ff, rarity: 0.3, duration: 12000, effect: () => {
                gameState.homingShotsActive = true; addTimedPowerup("üîÆ Homing", 12000, () => { gameState.homingShotsActive = false; });
            }},
            { name: "‚ö° Chain Lightning", color: 0xffff00, rarity: 0.25, duration: 14000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "‚ö° Chain")?.stacks || 0) + 1;
                gameState.chainLightningStacks = stacks;
                addTimedPowerup("‚ö° Chain", 14000, () => {
                    gameState.chainLightningStacks = gameState.activePowerups.find(p => p.name === "‚ö° Chain")?.stacks || 0;
                }, true);
            }},
            { name: "üî∂ Penetration", color: 0xff8844, rarity: 0.45, duration: 15000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "üî∂ Penetration")?.stacks || 0) + 1;
                gameState.penetrationCount = stacks;
                addTimedPowerup("üî∂ Penetration", 15000, () => {
                    gameState.penetrationCount = gameState.activePowerups.find(p => p.name === "üî∂ Penetration")?.stacks || 0;
                }, true);
            }},
            { name: "üí´ Ricochet", color: 0x88ffff, rarity: 0.35, duration: 12000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "üí´ Ricochet")?.stacks || 0) + 1;
                gameState.ricochetCount = stacks;
                addTimedPowerup("üí´ Ricochet", 12000, () => {
                    gameState.ricochetCount = gameState.activePowerups.find(p => p.name === "üí´ Ricochet")?.stacks || 0;
                }, true);
            }},
            { name: "üî• Burn Effect", color: 0xff4422, rarity: 0.4, duration: 16000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "üî• Burn")?.stacks || 0) + 1;
                gameState.burnStacks = stacks;
                addTimedPowerup("üî• Burn", 16000, () => {
                    gameState.burnStacks = gameState.activePowerups.find(p => p.name === "üî• Burn")?.stacks || 0;
                }, true);
            }},
            { name: "‚ùÑÔ∏è Freeze Shot", color: 0x88ddff, rarity: 0.35, duration: 14000, effect: () => {
                gameState.freezeShotActive = true; addTimedPowerup("‚ùÑÔ∏è Freeze", 14000, () => { gameState.freezeShotActive = false; });
            }},
            { name: "‚ò†Ô∏è Poison Rounds", color: 0x88ff44, rarity: 0.4, duration: 15000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "‚ò†Ô∏è Poison")?.stacks || 0) + 1;
                gameState.poisonStacks = stacks;
                addTimedPowerup("‚ò†Ô∏è Poison", 15000, () => {
                    gameState.poisonStacks = gameState.activePowerups.find(p => p.name === "‚ò†Ô∏è Poison")?.stacks || 0;
                }, true);
            }},

            // Defense & Survival
            { name: "üíé Armor Plating", color: 0x4488ff, rarity: 0.5, duration: 18000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "üíé Armor")?.stacks || 0) + 1;
                gameState.armorStacks = stacks;
                addTimedPowerup("üíé Armor", 18000, () => {
                    gameState.armorStacks = gameState.activePowerups.find(p => p.name === "üíé Armor")?.stacks || 0;
                }, true);
            }},
            { name: "üåü Dodge", color: 0xffff88, rarity: 0.35, duration: 15000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "üåü Dodge")?.stacks || 0) + 1;
                gameState.dodgeChance = Math.min(0.6, stacks * 0.15); // 15% dodge per stack, max 60%
                addTimedPowerup("üåü Dodge", 15000, () => {
                    const remaining = gameState.activePowerups.find(p => p.name === "üåü Dodge")?.stacks || 0;
                    gameState.dodgeChance = Math.max(0, remaining * 0.15);
                }, true);
            }},
            { name: "üíö Life Steal", color: 0x44ff88, rarity: 0.4, duration: 18000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "üíö Lifesteal")?.stacks || 0) + 1;
                gameState.lifeStealPercent = Math.min(0.5, stacks * 0.1); // 10% per stack, max 50%
                addTimedPowerup("üíö Lifesteal", 18000, () => {
                    const remaining = gameState.activePowerups.find(p => p.name === "üíö Lifesteal")?.stacks || 0;
                    gameState.lifeStealPercent = Math.max(0, remaining * 0.1);
                }, true);
            }},
            { name: "üåà Invincibility", color: 0xffffff, rarity: 0.08, duration: 5000, effect: () => {
                gameState.invincibleActive = true; addTimedPowerup("üåà Invincible", 5000, () => { gameState.invincibleActive = false; });
            }},
            { name: "üî∞ Thorns", color: 0xff8844, rarity: 0.35, duration: 15000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "üî∞ Thorns")?.stacks || 0) + 1;
                gameState.thornsStacks = stacks;
                addTimedPowerup("üî∞ Thorns", 15000, () => {
                    gameState.thornsStacks = gameState.activePowerups.find(p => p.name === "üî∞ Thorns")?.stacks || 0;
                }, true);
            }},

            // Resource & Utility
            { name: "üîã Ammo Regen", color: 0xffaa00, rarity: 0.5, duration: 20000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "üîã AmmoRegen")?.stacks || 0) + 1;
                gameState.ammoRegenStacks = stacks;
                addTimedPowerup("üîã AmmoRegen", 20000, () => {
                    gameState.ammoRegenStacks = gameState.activePowerups.find(p => p.name === "üîã AmmoRegen")?.stacks || 0;
                }, true);
            }},
            { name: "üì¶ Double Drops", color: 0xffdd44, rarity: 0.3, duration: 20000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "üì¶ Drops")?.stacks || 0) + 1;
                gameState.dropMultiplier = 1 + stacks;
                addTimedPowerup("üì¶ Drops", 20000, () => {
                    const remaining = gameState.activePowerups.find(p => p.name === "üì¶ Drops")?.stacks || 0;
                    gameState.dropMultiplier = Math.max(1, 1 + remaining);
                }, true);
            }},
            { name: "‚≠ê XP Boost", color: 0xffff00, rarity: 0.45, duration: 25000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "‚≠ê XP")?.stacks || 0) + 1;
                gameState.xpMultiplier = 1 + (stacks * 0.5);
                addTimedPowerup("‚≠ê XP", 25000, () => {
                    const remaining = gameState.activePowerups.find(p => p.name === "‚≠ê XP")?.stacks || 0;
                    gameState.xpMultiplier = Math.max(1, 1 + (remaining * 0.5));
                }, true);
            }},
            { name: "üîç Vision", color: 0x88ffff, rarity: 0.4, duration: 20000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "üîç Vision")?.stacks || 0) + 1;
                gameState.visionRange = 1 + (stacks * 0.3);
                addTimedPowerup("üîç Vision", 20000, () => {
                    const remaining = gameState.activePowerups.find(p => p.name === "üîç Vision")?.stacks || 0;
                    gameState.visionRange = Math.max(1, 1 + (remaining * 0.3));
                }, true);
            }},
            { name: "üí∞ Coin Magnet", color: 0xffdd00, rarity: 0.45, duration: 18000, effect: () => {
                gameState.coinMagnetActive = true; addTimedPowerup("üí∞ Coins", 18000, () => { gameState.coinMagnetActive = false; });
            }},

            // Special Effects & Ultimate
            { name: "üå™Ô∏è Vortex", color: 0x88ffaa, rarity: 0.2, duration: 12000, effect: () => {
                gameState.vortexActive = true; addTimedPowerup("üå™Ô∏è Vortex", 12000, () => { gameState.vortexActive = false; });
            }},
            { name: "‚ö° Static Field", color: 0x88aaff, rarity: 0.25, duration: 15000, effect: () => {
                gameState.staticFieldActive = true; addTimedPowerup("‚ö° Static", 15000, () => { gameState.staticFieldActive = false; });
            }},
            { name: "üåô Moon Gravity", color: 0xaaaaff, rarity: 0.3, duration: 15000, effect: () => {
                gameState.moonGravityActive = true; addTimedPowerup("üåô Gravity", 15000, () => { gameState.moonGravityActive = false; });
            }},
            { name: "üîÆ Orb Shield", color: 0xff88ff, rarity: 0.25, duration: 18000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "üîÆ Orbs")?.stacks || 0) + 1;
                gameState.orbitingOrbs = stacks;
                addTimedPowerup("üîÆ Orbs", 18000, () => {
                    gameState.orbitingOrbs = gameState.activePowerups.find(p => p.name === "üîÆ Orbs")?.stacks || 0;
                }, true);
            }},
            { name: "üé≠ Clone", color: 0xffaaff, rarity: 0.15, duration: 20000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "üé≠ Clone")?.stacks || 0) + 1;
                gameState.cloneCount = stacks;
                addTimedPowerup("üé≠ Clone", 20000, () => {
                    gameState.cloneCount = gameState.activePowerups.find(p => p.name === "üé≠ Clone")?.stacks || 0;
                }, true);
            }},
            { name: "üêù Swarm", color: 0xffff44, rarity: 0.2, duration: 16000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "üêù Swarm")?.stacks || 0) + 1;
                gameState.swarmCount = stacks * 3; // 3 bees per stack
                addTimedPowerup("üêù Swarm", 16000, () => {
                    const remaining = gameState.activePowerups.find(p => p.name === "üêù Swarm")?.stacks || 0;
                    gameState.swarmCount = remaining * 3;
                }, true);
            }},
            { name: "üåÄ Time Slow", color: 0xaaffff, rarity: 0.18, duration: 10000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "üåÄ TimeSlow")?.stacks || 0) + 1;
                gameState.timeSlowFactor = Math.max(0.3, 1 - (stacks * 0.2)); // Each stack slows by 20%
                addTimedPowerup("üåÄ TimeSlow", 10000, () => {
                    const remaining = gameState.activePowerups.find(p => p.name === "üåÄ TimeSlow")?.stacks || 0;
                    gameState.timeSlowFactor = remaining > 0 ? Math.max(0.3, 1 - (remaining * 0.2)) : 1;
                }, true);
            }},

            // Chaos & Random
            { name: "üé≤ Chaos", color: 0xff00ff, rarity: 0.25, effect: () => {
                // Random powerful effect
                const effects = [
                    () => { gameState.health = gameState.maxHealth; },
                    () => { gameState.ammo = gameState.maxAmmo; },
                    () => { gameState.speedMultiplier *= 2; setTimeout(() => gameState.speedMultiplier /= 2, 8000); },
                    () => { gameState.damageMultiplier *= 3; setTimeout(() => gameState.damageMultiplier /= 3, 6000); },
                    () => { enemies.forEach(e => e.health *= 0.5); },
                    () => { gameState.invincibleActive = true; addTimedPowerup("üé≤ Chaos Inv", 5000, () => { gameState.invincibleActive = false; }); }
                ];
                effects[Math.floor(Math.random() * effects.length)]();
            }},
            { name: "üé∞ Jackpot", color: 0xffaa00, rarity: 0.1, effect: () => {
                // Spawn multiple random powerups
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const offset = new THREE.Vector3((Math.random()-0.5)*10, 0, (Math.random()-0.5)*10);
                        spawnPowerup(camera.position.clone().add(offset));
                    }, i * 300);
                }
            }},
            { name: "üíÄ Curse of Power", color: 0x880088, rarity: 0.15, duration: 15000, effect: () => {
                // High risk, high reward
                gameState.damageMultiplier *= 3;
                gameState.maxHealth *= 0.5;
                gameState.health = Math.min(gameState.health, gameState.maxHealth);
                addTimedPowerup("üíÄ Curse", 15000, () => {
                    gameState.damageMultiplier /= 3;
                    gameState.maxHealth *= 2;
                });
            }},

            // Size & Scale
            { name: "üî∫ Size Up", color: 0xff88ff, rarity: 0.35, duration: 15000, stackable: true, effect: () => {
                const stacks = (gameState.activePowerups.find(p => p.name === "üî∫ Size")?.stacks || 0) + 1;
                gameState.sizeMultiplier = 1 + (stacks * 0.3);
                addTimedPowerup("üî∫ Size", 15000, () => {
                    const remaining = gameState.activePowerups.find(p => p.name === "üî∫ Size")?.stacks || 0;
                    gameState.sizeMultiplier = Math.max(1, 1 + (remaining * 0.3));
                }, true);
            }},
            { name: "üîª Mini Mode", color: 0x88ff88, rarity: 0.3, duration: 12000, effect: () => {
                gameState.sizeMultiplier = 0.5;
                gameState.dodgeChance = (gameState.dodgeChance || 0) + 0.3; // +30% dodge when small
                addTimedPowerup("üîª Mini", 12000, () => {
                    gameState.sizeMultiplier = 1;
                    gameState.dodgeChance = Math.max(0, (gameState.dodgeChance || 0) - 0.3);
                });
            }}
        ];
        
        let blackHoleMesh = null;
        let tornadoMesh = null;
        
        function activateBlackHole() {
            gameState.blackHoleActive = true;
            blackHoleMesh = new THREE.Mesh(
                new THREE.SphereGeometry(1, 32, 32),
                new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            const disk = new THREE.Mesh(
                new THREE.RingGeometry(2, 4, 32),
                new THREE.MeshBasicMaterial({ color: 0xaa00ff, side: THREE.DoubleSide, transparent: true, opacity: 0.8 })
            );
            disk.rotation.x = Math.PI / 2;
            blackHoleMesh.add(disk);
            
            blackHoleMesh.position.copy(camera.position).add(new THREE.Vector3(0, 5, -15).applyQuaternion(camera.quaternion));
            scene.add(blackHoleMesh);
            
            addTimedPowerup("üåå Singularity", 8000, () => { 
                gameState.blackHoleActive = false; 
                scene.remove(blackHoleMesh); 
                blackHoleMesh = null;
            });
        }
        
        function activateTornado() {
            gameState.tornadoActive = true;
            tornadoMesh = new THREE.Group();
            
            // Create spinning rings
            for (let i = 0; i < 5; i++) {
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(2 + i * 0.5, 0.3, 8, 16),
                    new THREE.MeshBasicMaterial({ color: 0xaaffaa, transparent: true, opacity: 0.6 })
                );
                ring.position.y = i * 2;
                ring.userData = { speed: (i + 1) * 0.1 };
                tornadoMesh.add(ring);
            }
            
            tornadoMesh.position.copy(camera.position).add(new THREE.Vector3(0, 0, -10).applyQuaternion(camera.quaternion));
            scene.add(tornadoMesh);
            
            addTimedPowerup("üå™Ô∏è Tornado", 10000, () => {
                gameState.tornadoActive = false;
                scene.remove(tornadoMesh);
                tornadoMesh = null;
            });
        }
        
        function activateOrbitalStrike() {
            // Find all enemies and drop strikes on them
            enemies.forEach(enemy => {
                const strike = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 1.5, 30, 8),
                    new THREE.MeshBasicMaterial({ color: 0xff0088, transparent: true, opacity: 0.8 })
                );
                strike.position.set(enemy.position.x, 20, enemy.position.z);
                strike.userData = { falling: true, speed: 0.5, target: enemy.position.clone() };
                scene.add(strike);
                particles.push(strike);
            });

            setTimeout(() => {
                enemies.forEach(e => {
                    e.health -= 80;
                    createExplosion(e.position, 0xff0088, 15);
                });
            }, 1000);
        }

        function activateNuke() {
            // Create a massive explosion effect
            createExplosion(camera.position, 0xff0000, 100);

            // Kill all non-boss enemies
            enemies.forEach(enemy => {
                if (!enemy.enemyType.isBoss) {
                    enemy.health = 0;
                } else {
                    enemy.health -= 100; // Damage bosses heavily
                }
            });

            // Flash the screen
            const flash = document.getElementById('damageFlash');
            flash.style.background = 'radial-gradient(ellipse at center, rgba(255, 255, 255, 0.8) 0%, rgba(255, 0, 0, 0.3) 100%)';
            flash.classList.add('active');
            setTimeout(() => {
                flash.classList.remove('active');
                flash.style.background = 'radial-gradient(ellipse at center, transparent 30%, rgba(255, 0, 0, 0.5) 100%)';
            }, 500);
        }

        // Powerup synergies - when certain combinations are active
        const POWERUP_SYNERGIES = [
            {
                combo: ["‚ö° Speed", "üî• Rapid"],
                name: "üí´ HYPERACTIVE",
                effect: () => {
                    gameState.hyperactiveBonus = true;
                    // Extra movement speed and fire rate
                    gameState.speedMultiplier *= 1.3;
                    gameState.fireRateMultiplier *= 1.3;
                }
            },
            {
                combo: ["üí• Damage", "üî• Rapid"],
                name: "üî¥ DESTRUCTION",
                effect: () => {
                    gameState.destructionBonus = true;
                    // Extra damage when both active
                    gameState.damageMultiplier *= 1.5;
                }
            },
            {
                combo: ["üõ°Ô∏è Shield", "üíö Regen"],
                name: "üè∞ FORTRESS",
                effect: () => {
                    gameState.fortressBonus = true;
                    // Increased max health
                    gameState.maxHealth *= 1.5;
                }
            },
            {
                combo: ["‚ö° Speed", "üëª GHOST"],
                name: "üë§ PHANTOM",
                effect: () => {
                    gameState.phantomBonus = true;
                    // Even more evasive
                    gameState.dodgeChance = Math.min(0.9, (gameState.dodgeChance || 0) + 0.3);
                }
            },
            {
                combo: ["üß≤ Magnet", "üßõ Vampire"],
                name: "üåÄ ABSORPTION",
                effect: () => {
                    gameState.absorptionBonus = true;
                    // Increased lifesteal
                    gameState.lifeStealPercent = Math.min(0.8, (gameState.lifeStealPercent || 0) + 0.2);
                }
            },
            {
                combo: ["üí• Damage", "‚öîÔ∏è Sword"],
                name: "‚öîÔ∏è BERSERKER",
                effect: () => {
                    gameState.berserkerBonus = true;
                    // Massively increased melee damage
                    gameState.damageMultiplier *= 1.8;
                }
            },
            {
                combo: ["üéØ AIM", "üî± Triple"],
                name: "üåü MARKSMAN",
                effect: () => {
                    gameState.marksmanBonus = true;
                    // Increased crit chance
                    gameState.critChance = Math.min(0.95, (gameState.critChance || 0) + 0.25);
                }
            },
            {
                combo: ["üî• Burn", "‚ùÑÔ∏è Freeze"],
                name: "üåä THERMAL SHOCK",
                effect: () => {
                    gameState.thermalShockBonus = true;
                    // Both elements deal massive damage
                }
            },
            {
                combo: ["üî∂ Penetration", "üí´ Ricochet"],
                name: "üéØ BULLET HELL",
                effect: () => {
                    gameState.bulletHellBonus = true;
                    // Bullets bounce AND penetrate
                }
            },
            {
                combo: ["üíé Armor", "üî∞ Thorns"],
                name: "üõ°Ô∏è IRONCLAD",
                effect: () => {
                    gameState.ironcladBonus = true;
                    // Double armor and thorns damage
                    gameState.armorStacks *= 2;
                    gameState.thornsStacks *= 2;
                }
            },
            {
                combo: ["üé≠ Clone", "üêù Swarm"],
                name: "üë• ARMY",
                effect: () => {
                    gameState.armyBonus = true;
                    // Extra clones and swarm units
                    gameState.cloneCount = Math.floor(gameState.cloneCount * 1.5);
                    gameState.swarmCount = Math.floor(gameState.swarmCount * 1.5);
                }
            },
            {
                combo: ["‚ö° Chain", "‚ö° Static"],
                name: "‚ö° STORM LORD",
                effect: () => {
                    gameState.stormLordBonus = true;
                    // Massive electric synergy
                    gameState.chainLightningStacks *= 2;
                }
            }
        ];

        function checkPowerupSynergies() {
            const activeNames = gameState.activePowerups.map(p => p.name);
            const previousSynergies = gameState.activePowerups.filter(p => p.isSynergy).map(p => p.name);

            // Reset all synergy bonuses
            gameState.hyperactiveBonus = false;
            gameState.destructionBonus = false;
            gameState.fortressBonus = false;
            gameState.phantomBonus = false;
            gameState.absorptionBonus = false;
            gameState.berserkerBonus = false;
            gameState.marksmanBonus = false;
            gameState.thermalShockBonus = false;
            gameState.bulletHellBonus = false;
            gameState.ironcladBonus = false;
            gameState.armyBonus = false;
            gameState.stormLordBonus = false;

            // Clear existing synergies
            gameState.activePowerups = gameState.activePowerups.filter(p => !p.isSynergy);

            // Check each synergy
            POWERUP_SYNERGIES.forEach(synergy => {
                if (synergy.combo.every(name => activeNames.includes(name))) {
                    // Activate synergy
                    synergy.effect();

                    // Add synergy to active powerups list for display
                    if (!gameState.activePowerups.find(p => p.name === synergy.name)) {
                        gameState.activePowerups.push({
                            name: synergy.name,
                            endTime: Infinity,
                            isSynergy: true,
                            stacks: 1
                        });

                        // Show notification for new synergies
                        if (!previousSynergies.includes(synergy.name)) {
                            showPowerupNotification(`‚ú® SYNERGY: ${synergy.name} ‚ú®`);
                        }
                    }
                }
            });
        }

        function addTimedPowerup(name, duration, onEnd, stackable = false) {
            const existing = gameState.activePowerups.find(p => p.name === name);

            if (existing && stackable) {
                // Stack the powerup
                existing.stacks = (existing.stacks || 1) + 1;
                existing.endTime = Math.max(existing.endTime, Date.now() + duration); // Extend if new duration is longer
                existing.stackEndTimes = existing.stackEndTimes || [];
                existing.stackEndTimes.push(Date.now() + duration);
                existing.onEndCallbacks = existing.onEndCallbacks || [existing.onEnd];
                existing.onEndCallbacks.push(onEnd);
            } else if (!stackable) {
                // Replace existing non-stackable powerup
                gameState.activePowerups = gameState.activePowerups.filter(p => p.name !== name);
                gameState.activePowerups.push({ name, endTime: Date.now() + duration, onEnd, stacks: 1 });
            } else {
                // New stackable powerup
                gameState.activePowerups.push({
                    name,
                    endTime: Date.now() + duration,
                    onEnd,
                    stacks: 1,
                    stackEndTimes: [Date.now() + duration],
                    onEndCallbacks: [onEnd]
                });
            }

            // Check for synergies
            checkPowerupSynergies();
        }

        function spawnPowerup(position) {
            const totalWeight = POWERUP_TYPES.reduce((sum, p) => sum + p.rarity, 0);
            let rand = Math.random() * totalWeight;
            let powerup = POWERUP_TYPES[0];
            for (const p of POWERUP_TYPES) {
                rand -= p.rarity;
                if (rand <= 0) { powerup = p; break; }
            }
            
            const group = new THREE.Group();
            const glow = new THREE.Mesh(new THREE.SphereGeometry(0.9, 16, 16), new THREE.MeshBasicMaterial({ color: powerup.color, transparent: true, opacity: 0.4 }));
            group.add(glow);
            const core = new THREE.Mesh(new THREE.OctahedronGeometry(0.45, 0), new THREE.MeshStandardMaterial({ color: powerup.color, emissive: powerup.color, emissiveIntensity: 1 }));
            group.add(core);
            const ring = new THREE.Mesh(new THREE.TorusGeometry(0.6, 0.08, 8, 16), new THREE.MeshBasicMaterial({ color: powerup.color }));
            ring.rotation.x = Math.PI / 2;
            group.add(ring);
            
            group.position.copy(position);
            group.position.y = 1.5;
            group.powerupData = powerup;
            scene.add(group);
            powerupObjects.push({ mesh: group, powerup, time: 0 });
        }

        function showPowerupNotification(name) {
            const el = document.getElementById('powerupNotification');
            el.textContent = name;
            el.classList.add('show');
            setTimeout(() => el.classList.remove('show'), 1500);
        }

        function updatePowerups() {
            powerupObjects.forEach((obj, idx) => {
                obj.time++;
                obj.mesh.rotation.y += 0.05;
                obj.mesh.children[2].rotation.z += 0.05;
                obj.mesh.position.y = 1.5 + Math.sin(obj.time * 0.07) * 0.35;

                if (gameState.magnetActive || gameState.titanMode) {
                    const dir = new THREE.Vector3().subVectors(camera.position, obj.mesh.position);
                    if (dir.length() < 20) {
                        dir.normalize();
                        obj.mesh.position.addScaledVector(dir, 0.3);
                    }
                }

                const dist = obj.mesh.position.distanceTo(camera.position);
                if (dist < 3) {
                    obj.powerup.effect();
                    showPowerupNotification(obj.powerup.name);
                    createParticleBurst(obj.mesh.position, obj.powerup.color, 25);
                    scene.remove(obj.mesh);
                    powerupObjects.splice(idx, 1);
                }

                if (obj.time > 900) {
                    scene.remove(obj.mesh);
                    powerupObjects.splice(idx, 1);
                }
            });

            gameState.activePowerups = gameState.activePowerups.filter(p => {
                // Don't expire synergies
                if (p.isSynergy) return true;

                // Handle stacked powerups
                if (p.stacks > 1 && p.stackEndTimes) {
                    // Remove expired stacks
                    const now = Date.now();
                    const expiredCount = p.stackEndTimes.filter(t => t <= now).length;

                    if (expiredCount > 0) {
                        // Remove expired callbacks
                        for (let i = 0; i < expiredCount; i++) {
                            const callback = p.onEndCallbacks.shift();
                            if (callback) callback();
                        }

                        // Remove expired times
                        p.stackEndTimes = p.stackEndTimes.filter(t => t > now);
                        p.stacks -= expiredCount;

                        // Update end time to next expiring stack
                        if (p.stackEndTimes.length > 0) {
                            p.endTime = Math.max(...p.stackEndTimes);
                        }

                        // Recheck synergies after stack changes
                        checkPowerupSynergies();
                    }

                    // Keep if still has stacks
                    return p.stacks > 0;
                }

                // Handle non-stacked powerups
                if (p.endTime <= Date.now()) {
                    if (p.onEnd) p.onEnd();
                    // Recheck synergies after powerup removal
                    setTimeout(() => checkPowerupSynergies(), 0);
                    return false;
                }

                return true;
            });
        }

        // ===== PARTICLE SYSTEM =====
        const particles = [];
        function createParticle(pos, color, vel, life = 50) {
            const p = new THREE.Mesh(new THREE.SphereGeometry(0.15, 4, 4), new THREE.MeshBasicMaterial({ color, transparent: true }));
            p.position.copy(pos);
            p.velocity = vel;
            p.life = life;
            p.maxLife = life;
            scene.add(p);
            particles.push(p);
        }

        function createParticleBurst(pos, color, count) {
            // Reduced particle count
            const actualCount = Math.min(count, 15);
            for (let i = 0; i < actualCount; i++) {
                createParticle(pos.clone(), color, new THREE.Vector3((Math.random()-0.5)*0.5, Math.random()*0.5, (Math.random()-0.5)*0.5), 30);
            }
        }

        function createExplosion(pos, color, count) {
            // Reduced particle count
            const actualCount = Math.min(count, 12);
            createParticleBurst(pos, color, actualCount);
            const ring = new THREE.Mesh(new THREE.RingGeometry(0.5, 0.8, 16), new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.9, side: THREE.DoubleSide }));
            ring.position.copy(pos);
            ring.position.y = 1;
            ring.rotation.x = -Math.PI / 2;
            ring.userData = { expanding: true, life: 20 };
            scene.add(ring);
            particles.push(ring);
        }

        function updateParticles() {
            particles.forEach((p, idx) => {
                if (p.userData && p.userData.expanding) {
                    p.scale.x += 0.8;
                    p.scale.y += 0.8;
                    p.material.opacity -= 0.04;
                    p.userData.life--;
                    if (p.userData.life <= 0) { scene.remove(p); particles.splice(idx, 1); }
                } else if (p.userData && p.userData.falling) {
                    // Orbital strike falling
                    p.position.y -= p.userData.speed;
                    p.userData.speed += 0.1; // Accelerate
                    if (p.position.y <= 1) {
                        createExplosion(p.userData.target, 0xff0088, 15);
                        scene.remove(p);
                        particles.splice(idx, 1);
                    }
                } else {
                    p.position.add(p.velocity);
                    p.velocity.y -= 0.01;
                    p.life--;
                    p.material.opacity = p.life / p.maxLife;
                    if (p.life <= 0) { scene.remove(p); particles.splice(idx, 1); }
                }
            });
            
            if (dustSystem) {
                dustSystem.rotation.y += 0.0005;
                const pos = dustSystem.geometry.attributes.position.array;
                for(let i=1; i<pos.length; i+=3) {
                    pos[i] -= 0.02;
                    if(pos[i] < 0) pos[i] = 20;
                }
                dustSystem.geometry.attributes.position.needsUpdate = true;
            }
            
            // Animate Black Hole
            if (gameState.blackHoleActive && blackHoleMesh) {
                blackHoleMesh.children[0].rotation.z += 0.1;
                blackHoleMesh.scale.setScalar(1 + Math.sin(Date.now() * 0.01) * 0.1);
            }
            
            // Animate Tornado
            if (gameState.tornadoActive && tornadoMesh) {
                tornadoMesh.children.forEach(ring => {
                    ring.rotation.y += ring.userData.speed;
                });
                tornadoMesh.position.y = Math.sin(Date.now() * 0.002) * 2;
            }
        }

        // ===== PROJECTILE SYSTEM =====
        const projectiles = [];
        let lastFireTime = 0;
        const BASE_FIRE_RATE = 150;

        function createProjectile() {
            if (gameState.paused) return;
            
            if (gameState.inSafeRoom) {
                const warn = document.getElementById('warningNotification');
                warn.textContent = "üö´ WEAPONS DISABLED IN SAFE ROOM";
                warn.classList.add('show');
                setTimeout(() => warn.classList.remove('show'), 1500);
                return;
            }

            if (gameState.ammo <= 0 && !gameState.titanMode) {
                showQuestion();
                return;
            }
            
            const now = Date.now();
            const fireDelay = gameState.godBeamActive ? 20 : (BASE_FIRE_RATE / gameState.fireRateMultiplier);
            if (now - lastFireTime < fireDelay) return;
            lastFireTime = now;
            
            if (!gameState.godBeamActive && !gameState.titanMode) gameState.ammo--;

            const color = gameState.godBeamActive ? 0x00ffff : (gameState.titanMode ? 0xffaa00 : (gameState.explosiveRoundsActive ? 0xff6600 : 0x00ff00));
            const scale = gameState.titanMode ? 0.8 : 0.18;

            const createSingleProjectile = (angleOffset = 0) => {
                const proj = new THREE.Mesh(
                    new THREE.SphereGeometry(scale, 8, 8),
                    new THREE.MeshBasicMaterial({ color: color })
                );

                proj.position.copy(camera.position);
                proj.position.y -= gameState.titanMode ? 1.0 : 0.2;

                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);

                // Apply angle offset for triple shot
                if (angleOffset !== 0) {
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    forward.applyAxisAngle(right, angleOffset);
                }

                proj.velocity = forward.clone().multiplyScalar(gameState.godBeamActive ? 2.5 : 1.0);
                proj.life = 100;
                proj.hitEnemies = new Set();
                proj.isGodBeam = gameState.godBeamActive;
                proj.isExplosive = gameState.explosiveRoundsActive;

                scene.add(proj);
                projectiles.push(proj);
            };

            // Triple shot: fire 3 projectiles
            if (gameState.tripleShotActive) {
                createSingleProjectile(-0.15); // Left
                createSingleProjectile(0);      // Center
                createSingleProjectile(0.15);   // Right
            } else {
                createSingleProjectile();
            }
        }

        function showHitMarker() {
            const marker = document.getElementById('hitMarker');
            marker.classList.add('show');
            setTimeout(() => marker.classList.remove('show'), 100);
        }

        function updateProjectiles() {
            projectiles.forEach((proj, idx) => {
                // Auto-aim
                if (gameState.autoAimActive && enemies.length > 0) {
                    let closest = null;
                    let closestDist = 50;
                    enemies.forEach(e => {
                        const d = e.position.distanceTo(proj.position);
                        if (d < closestDist) { closest = e; closestDist = d; }
                    });
                    if (closest) {
                        const dir = new THREE.Vector3().subVectors(closest.position, proj.position).normalize();
                        proj.velocity.lerp(dir.multiplyScalar(proj.velocity.length()), 0.15);
                    }
                }
                
                proj.position.add(proj.velocity);
                proj.life--;

                if (proj.life <= 0) {
                    scene.remove(proj);
                    projectiles.splice(idx, 1);
                    return;
                }

                let hitEnemy = null;
                enemies.forEach(enemy => {
                    const dist = proj.position.distanceTo(enemy.position);
                    if ((dist < enemy.hitRadius || enemy.boundingBox.containsPoint(proj.position)) && !proj.hitEnemies.has(enemy)) {
                        hitEnemy = enemy;
                    }
                });

                if (hitEnemy) {
                    const damage = (gameState.titanMode ? 50 : 6) * gameState.damageMultiplier;
                    hitEnemy.health -= damage;
                    proj.hitEnemies.add(hitEnemy);

                    createParticleBurst(proj.position, 0x00ff00, 3);
                    showHitMarker();

                    // Explosive Rounds - area damage on hit
                    if (proj.isExplosive) {
                        createExplosion(proj.position, 0xff6600, 12);
                        enemies.forEach(e => {
                            if (e.position.distanceTo(proj.position) < 5) {
                                e.health -= damage * 0.6;
                            }
                        });
                    }

                    // Lightning Chain - damage spreads to nearby enemies
                    if (gameState.lightningChainActive) {
                        enemies.forEach(e => {
                            if (e !== hitEnemy && e.position.distanceTo(hitEnemy.position) < 8) {
                                e.health -= damage * 0.5;
                                // Visual lightning effect
                                createParticleBurst(e.position, 0xffff00, 2);
                            }
                        });
                    }

                    if (!gameState.piercingActive && !proj.isGodBeam && !gameState.titanMode) {
                        scene.remove(proj);
                        projectiles.splice(idx, 1);
                    }
                }
            });
        }
        
        // ===== BOMB SYSTEM =====
        const bombs = [];
        function dropBomb() {
            if (gameState.paused || gameState.inSafeRoom) return;
            if (gameState.bombs <= 0) return;
            gameState.bombs--;
            
            const bomb = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), new THREE.MeshStandardMaterial({ color: 0x222222, emissive: 0xff0044, emissiveIntensity: 1 }));
            bomb.position.copy(camera.position);
            bomb.position.y = 0.6;
            bomb.timer = 80;
            scene.add(bomb);
            bombs.push(bomb);
        }

        function updateBombs() {
            bombs.forEach((bomb, idx) => {
                bomb.timer--;
                bomb.scale.setScalar(1 + Math.sin(Date.now() * 0.05) * 0.2);
                if (bomb.timer <= 0) {
                    createExplosion(bomb.position, 0xff4400, 60);
                    enemies.forEach(enemy => {
                        const dist = enemy.position.distanceTo(bomb.position);
                        if (dist < 18) enemy.health -= 50 * (1 - dist / 18);
                    });
                    scene.remove(bomb);
                    bombs.splice(idx, 1);
                }
            });
        }

        // ===== QUESTION SYSTEM =====
        function showQuestion(fromSafeRoom = false) {
            if (gameState.questionActive || gameState.gameOver) return;
            
            // Exit pointer lock to show cursor
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }
            
            gameState.questionActive = true;
            gameState.paused = true;
            gameState.pauseStartTime = Date.now();
            gameState.safeRoomMode = fromSafeRoom;
            
            document.getElementById('pausedOverlay').classList.add('show');
            
            if (questionIndex >= shuffledQuestions.length) {
                shuffledQuestions = shuffleArray([...QUESTION_POOL]);
                questionIndex = 0;
            }
            
            const q = shuffledQuestions[questionIndex++];
            const correctAnswer = q.a[q.c];
            const shuffledAnswers = [...q.a];
            for (let i = shuffledAnswers.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledAnswers[i], shuffledAnswers[j]] = [shuffledAnswers[j], shuffledAnswers[i]];
            }
            
            gameState.currentQuestion = { q: q.q, a: shuffledAnswers, c: shuffledAnswers.indexOf(correctAnswer), cat: q.cat };
            
            document.getElementById('questionCategory').textContent = fromSafeRoom ? 'üìö SAFE ROOM STUDY - ' + q.cat : q.cat;
            document.getElementById('questionText').textContent = q.q;
            document.getElementById('feedback').textContent = '';
            document.getElementById('feedback').className = '';
            
            const options = document.getElementById('optionsContainer');
            options.innerHTML = '';
            
            shuffledAnswers.forEach((answer, idx) => {
                const btn = document.createElement('button');
                btn.className = 'option-button';
                btn.textContent = answer;
                btn.onclick = () => checkAnswer(idx);
                options.appendChild(btn);
            });
            
            document.getElementById('questionModal').classList.add('active');
        }

        function checkAnswer(idx) {
            const q = gameState.currentQuestion;
            const correct = idx === q.c;
            const inSafeRoom = gameState.safeRoomMode;
            
            document.querySelectorAll('.option-button').forEach((btn, i) => {
                btn.disabled = true;
                if (i === q.c) btn.classList.add('correct');
                if (i === idx && i !== q.c) btn.classList.add('incorrect');
            });
            
            const feedback = document.getElementById('feedback');
            if (correct) {
                let bonus = 50 + gameState.streak * 10;
                feedback.textContent = `‚úì Correct! +25 Ammo, +${bonus} Score`;
                feedback.className = 'correct';
                gameState.ammo = Math.min(gameState.maxAmmo, gameState.ammo + 25);
                gameState.correct++;
                gameState.score += bonus;
                gameState.streak++;
                
                const offset = new THREE.Vector3((Math.random()-0.5)*(inSafeRoom?2:8), 0, (Math.random()-0.5)*(inSafeRoom?2:8));
                spawnPowerup(inSafeRoom ? new THREE.Vector3(SAFE_ROOM.x + 12, 0, SAFE_ROOM.z) : camera.position.clone().add(offset));
            } else {
                const healthPenalty = inSafeRoom ? 5 : 20;
                feedback.textContent = `‚úó Wrong! -${healthPenalty} Health`;
                feedback.className = 'incorrect';
                gameState.health -= healthPenalty;
                gameState.wrong++;
                gameState.streak = 0;
                showDamageFlash();
            }
            
            setTimeout(() => {
                document.getElementById('questionModal').classList.remove('active');
                document.getElementById('pausedOverlay').classList.remove('show');
                gameState.questionActive = false;
                gameState.safeRoomMode = false;
                
                const pauseDuration = Date.now() - gameState.pauseStartTime;
                gameState.activePowerups.forEach(p => { p.endTime += pauseDuration; });
                
                gameState.paused = false;
                animate();
            }, 1800);
        }

        function showDamageFlash() {
            const flash = document.getElementById('damageFlash');
            flash.classList.add('active');
            setTimeout(() => flash.classList.remove('active'), 120);
        }

        // ===== MINIMAP =====
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        minimapCanvas.width = 120; minimapCanvas.height = 120;

        function updateMinimap() {
            minimapCtx.fillStyle = 'rgba(0, 15, 30, 0.95)';
            minimapCtx.fillRect(0, 0, 120, 120);
            const scale = 120 / (ARENA_SIZE * 2);
            const ox = 60, oy = 60;
            
            minimapCtx.fillStyle = 'rgba(0, 255, 100, 0.3)';
            minimapCtx.fillRect((SAFE_ROOM.x - SAFE_ROOM.width/2) * scale + ox, (SAFE_ROOM.z - SAFE_ROOM.depth/2) * scale + oy, SAFE_ROOM.width * scale, SAFE_ROOM.depth * scale);
            
            enemies.forEach(e => {
                minimapCtx.fillStyle = e.enemyType.kamikaze ? '#ff0000' : '#ff3333';
                minimapCtx.beginPath();
                minimapCtx.arc(e.position.x * scale + ox, e.position.z * scale + oy, 2, 0, Math.PI * 2);
                minimapCtx.fill();
            });
            
            minimapCtx.fillStyle = '#00ffff';
            minimapCtx.beginPath();
            minimapCtx.arc(camera.position.x * scale + ox, camera.position.z * scale + oy, 3, 0, Math.PI * 2);
            minimapCtx.fill();
        }

        // ===== MAIN LOOP =====
        function checkLevelProgress() {
            const newLevel = Math.floor((gameState.correct * 3 + gameState.score / 400) / 10) + 1;
            if (newLevel > gameState.level && newLevel <= 10) {
                gameState.level = newLevel;
                const indicator = document.getElementById('levelIndicator');
                indicator.textContent = `LEVEL ${newLevel}`;
                indicator.classList.add('show');
                setTimeout(() => indicator.classList.remove('show'), 2500);
                generateLevel(newLevel);
                gameState.health = Math.min(gameState.maxHealth, gameState.health + 30);
                gameState.ammo = Math.min(gameState.maxAmmo, gameState.ammo + 20);
            }
        }
        
        let shieldMesh = null;
        function updateShieldVisual() {
            if (gameState.shieldActive && !shieldMesh) {
                shieldMesh = new THREE.Mesh(new THREE.SphereGeometry(2.5, 20, 20), new THREE.MeshBasicMaterial({ color: 0x4488ff, transparent: true, opacity: 0.2, wireframe: true }));
                scene.add(shieldMesh);
            }
            if (shieldMesh) {
                if (gameState.shieldActive) {
                    shieldMesh.position.copy(camera.position);
                    shieldMesh.rotation.y += 0.05;
                } else {
                    scene.remove(shieldMesh);
                    shieldMesh = null;
                }
            }
        }

        function animate() {
            if (gameState.gameOver) return;
            if (gameState.paused) return;
            
            requestAnimationFrame(animate);

            // Movement - Standard FPS controls
            const moveSpeed = (gameState.titanMode ? 0.35 : 0.18) * gameState.speedMultiplier;
            const moveDir = new THREE.Vector3();
            
            // WASD and Arrow Keys - Standard FPS layout
            if (keys['w'] || keys['ArrowUp']) moveDir.z -= 1;      // Forward
            if (keys['s'] || keys['ArrowDown']) moveDir.z += 1;    // Backward
            if (keys['a'] || keys['ArrowLeft']) moveDir.x -= 1;    // Strafe Left
            if (keys['d'] || keys['ArrowRight']) moveDir.x += 1;   // Strafe Right
            
            if (moveDir.length() > 0) {
                moveDir.normalize();
                // Apply camera rotation to movement direction for proper FPS controls
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                forward.y = 0;
                forward.normalize();
                
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                right.y = 0;
                right.normalize();
                
                const actualMove = new THREE.Vector3();
                actualMove.addScaledVector(forward, -moveDir.z); // Note: -z because forward is in -z direction
                actualMove.addScaledVector(right, moveDir.x);
                
                camera.position.addScaledVector(actualMove, moveSpeed);
                camera.position.x = Math.max(-ARENA_SIZE + 2, Math.min(ARENA_SIZE - 2, camera.position.x));
                camera.position.z = Math.max(-ARENA_SIZE + 2, Math.min(ARENA_SIZE - 2, camera.position.z));
            }

            // Auto fire
            if (keys[' '] && !gameState.questionActive) {
                createProjectile();
            }

            updateEnemies();
            updatePowerups();
            updateProjectiles();
            updateParticles();
            updateBombs();
            updateTraps();
            updateShieldVisual();
            updateMinimap();
            updateSafeRoomStatus();
            checkLevelProgress();

            // Health Regen powerup
            if (gameState.healthRegenActive && Math.random() > 0.92) {
                gameState.health = Math.min(gameState.maxHealth, gameState.health + 0.5);
            }

            // Sword Aura powerup - damages nearby enemies
            if (gameState.swordAuraActive) {
                enemies.forEach(enemy => {
                    const dist = enemy.position.distanceTo(camera.position);
                    if (dist < 6) {
                        enemy.health -= 0.8;
                        if (Math.random() > 0.9) createParticleBurst(enemy.position, 0xffaa00, 2);
                    }
                });
            }

            // UI
            document.getElementById('health').textContent = Math.ceil(gameState.health);
            document.getElementById('healthBar').style.width = (gameState.health / gameState.maxHealth * 100) + '%';
            document.getElementById('ammo').textContent = gameState.ammo;
            document.getElementById('ammoBar').style.width = (gameState.ammo / gameState.maxAmmo * 100) + '%';
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('streak').textContent = gameState.streak;
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('bombCount').textContent = gameState.bombs;
            document.getElementById('enemyCount').textContent = enemies.length;
            document.getElementById('correct').textContent = gameState.correct;
            document.getElementById('wrong').textContent = gameState.wrong;

            document.getElementById('powerupsList').innerHTML = gameState.activePowerups.map(p => {
                const rem = Math.max(0, Math.ceil((p.endTime - Date.now()) / 1000));
                const stackText = p.stacks > 1 ? ` x${p.stacks}` : '';
                const synergyStyle = p.isSynergy ? ' style="color: #f0f; font-weight: bold; text-shadow: 0 0 10px #f0f;"' : '';
                const timeText = p.isSynergy ? 'SYNERGY' : `${rem}s`;
                return `<div class="powerup-item"${synergyStyle}>${p.name}${stackText} (${timeText})</div>`;
            }).join('');

            if (gameState.health <= 0) {
                gameState.gameOver = true;
                document.getElementById('gameOverText').innerHTML = `
                    <div style="font-size: 26px; margin-bottom: 12px;">üíÄ GAME OVER</div>
                    <div>Score: <span style="color: #0ff;">${gameState.score}</span></div>
                    <div>Level: <span style="color: #0ff;">${gameState.level}</span></div>
                    <div>Correct: <span style="color: #0f0;">${gameState.correct}</span> / Wrong: <span style="color: #f44;">${gameState.wrong}</span></div>
                `;
                document.getElementById('gameMessage').style.display = 'block';
            }

            renderer.render(scene, camera);
        }

        // Initialize game after questions are loaded
        loadQuestions().then(() => {
            generateLevel(1);
            for (let i = 0; i < 4; i++) createEnemy();
            animate();
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
