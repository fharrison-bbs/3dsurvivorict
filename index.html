<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G9 Computer Science Arena - Desktop Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #000;
            color: #fff;
        }
        
        body.pointer-locked {
            cursor: none;
        }
        
        #gameContainer {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        /* ===== UI PANELS ===== */
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.95), rgba(0, 40, 60, 0.9));
            padding: 12px 16px;
            border-radius: 12px;
            font-size: 11px;
            min-width: 160px;
            z-index: 5;
            border: 1px solid rgba(0, 200, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 100, 150, 0.3);
            pointer-events: none;
        }
        
        #stats {
            position: absolute;
            top: 10px;
            right: 10px;
            background: linear-gradient(135deg, rgba(40, 0, 40, 0.95), rgba(60, 0, 60, 0.9));
            padding: 10px 14px;
            border-radius: 12px;
            font-size: 10px;
            text-align: right;
            z-index: 5;
            border: 1px solid rgba(200, 0, 255, 0.3);
            box-shadow: 0 0 20px rgba(150, 0, 150, 0.3);
            pointer-events: none;
        }
        
        .stat-line {
            margin: 4px 0;
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        
        .stat-label { color: #aac; }
        .stat-value { 
            color: #0ff; 
            font-weight: bold; 
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.5); 
        }
        
        .bar-container {
            width: 130px;
            height: 12px;
            background: #111;
            border: 2px solid #333;
            border-radius: 6px;
            overflow: hidden;
            margin-top: 4px;
        }
        
        .bar-fill {
            height: 100%;
            transition: width 0.3s;
            box-shadow: inset 0 2px 4px rgba(255,255,255,0.2);
        }
        
        .health-fill { background: linear-gradient(90deg, #0f0, #0a0); }
        .ammo-fill { background: linear-gradient(90deg, #ff0, #fa0); }
        
        /* ===== LEVEL INDICATOR ===== */
        #levelIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 42px;
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 30px #0ff, 0 0 60px #00f;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
        
        #levelIndicator.show { opacity: 1; }
        
        /* ===== POWERUP NOTIFICATION ===== */
        #powerupNotification {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 20px;
            border: 2px solid #fd0;
            font-size: 14px;
            color: #fd0;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            white-space: nowrap;
        }
        
        #powerupNotification.show { opacity: 1; }

        #warningNotification {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(50, 0, 0, 0.9);
            padding: 10px 20px;
            border-radius: 5px;
            border: 2px solid #f00;
            font-size: 16px;
            font-weight: bold;
            color: #f00;
            z-index: 50;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            text-transform: uppercase;
            text-shadow: 0 0 10px #f00;
        }
        
        #warningNotification.show { opacity: 1; }
        
        /* ===== QUESTION MODAL ===== */
        #questionModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.97);
            z-index: 100;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            padding: 15px;
        }
        
        #questionModal.active { display: flex; }
        
        #questionContainer {
            background: linear-gradient(135deg, rgba(0, 30, 60, 0.98), rgba(0, 50, 80, 0.95));
            border: 3px solid #0cf;
            border-radius: 16px;
            padding: 20px;
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(0, 200, 255, 0.3);
        }
        
        #questionCategory {
            font-size: 10px;
            color: #0cf;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 8px;
            opacity: 0.8;
        }
        
        #questionText {
            font-size: 16px;
            margin-bottom: 18px;
            line-height: 1.5;
            color: #fff;
        }
        
        .option-button {
            width: 100%;
            padding: 14px 16px;
            margin: 6px 0;
            background: linear-gradient(135deg, rgba(0, 80, 100, 0.6), rgba(0, 60, 80, 0.4));
            border: 2px solid #0aa;
            color: #fff;
            border-radius: 10px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }
        
        .option-button:hover {
            background: rgba(0, 200, 255, 0.3);
            transform: scale(1.02);
        }
        
        .option-button.correct {
            background: linear-gradient(135deg, rgba(0, 180, 0, 0.8), rgba(0, 140, 0, 0.6));
            border-color: #0f0;
        }
        
        .option-button.incorrect {
            background: linear-gradient(135deg, rgba(200, 0, 0, 0.8), rgba(150, 0, 0, 0.6));
            border-color: #f00;
        }
        
        #feedback {
            margin-top: 15px;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            min-height: 25px;
        }
        
        #feedback.correct { color: #0f0; text-shadow: 0 0 15px #0f0; }
        #feedback.incorrect { color: #f44; text-shadow: 0 0 15px #f00; }
        
        /* ===== ACTIVE POWERUPS ===== */
        #activePowerups {
            position: absolute;
            top: 120px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border-radius: 10px;
            max-width: 150px;
            font-size: 9px;
            z-index: 5;
            border: 1px solid rgba(255, 200, 0, 0.4);
            pointer-events: none;
        }
        
        .powerup-item {
            padding: 4px 6px;
            margin: 2px 0;
            background: rgba(255, 200, 0, 0.15);
            border-left: 3px solid #fd0;
            border-radius: 4px;
            color: #fd0;
        }
        
        /* ===== MINIMAP ===== */
        #minimap {
            position: absolute;
            bottom: 20px;
            left: 10px;
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #0aa;
            border-radius: 8px;
            z-index: 5;
            overflow: hidden;
            pointer-events: none;
        }
        
        #minimapCanvas {
            width: 100%;
            height: 100%;
        }
        
        /* ===== CROSSHAIR ===== */
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            pointer-events: none;
            z-index: 2;
        }
        
        .crosshair-line {
            position: absolute;
            background: rgba(0, 255, 255, 0.8);
        }
        
        .crosshair-line.h {
            width: 16px;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .crosshair-line.v {
            width: 2px;
            height: 16px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .crosshair-line.left { left: 0; }
        .crosshair-line.right { right: 0; }
        .crosshair-line.top { top: 0; }
        .crosshair-line.bottom { bottom: 0; }
        
        .crosshair-dot {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: #0ff;
            border-radius: 50%;
            box-shadow: 0 0 10px #0ff;
        }
        
        /* ===== DAMAGE FLASH ===== */
        #damageFlash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 30%, rgba(255, 0, 0, 0.5) 100%);
            pointer-events: none;
            z-index: 3;
            opacity: 0;
            transition: opacity 0.1s;
        }
        
        #damageFlash.active { opacity: 1; }
        
        /* ===== GAME MESSAGE ===== */
        #gameMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 0, 40, 0.95));
            border: 3px solid #f0a;
            padding: 25px 35px;
            border-radius: 16px;
            text-align: center;
            font-size: 18px;
            z-index: 50;
            display: none;
            box-shadow: 0 0 50px rgba(255, 0, 150, 0.4);
        }
        
        #pausedOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 99;
            display: none;
            pointer-events: none;
        }
        
        #pausedOverlay.show {
            display: block;
        }
        
        #pausedText {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            font-weight: bold;
            color: #0ff;
            text-shadow: 0 0 20px #0ff;
            letter-spacing: 4px;
        }
        
        #safeRoomIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -80%);
            background: linear-gradient(135deg, rgba(0, 100, 50, 0.95), rgba(0, 150, 80, 0.9));
            border: 3px solid #0f8;
            padding: 15px 30px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            z-index: 20;
            display: none;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 255, 100, 0.4);
        }
        
        #safeRoomIndicator.show {
            display: block;
        }
        
        #safeRoomIndicator .subtitle {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 5px;
        }
        
        #safeRoomIndicator .warning {
            color: #fca;
            font-size: 10px;
            margin-top: 5px;
            font-weight: bold;
        }
        
        #restartBtn {
            margin-top: 20px;
            padding: 14px 35px;
            font-size: 16px;
            background: linear-gradient(135deg, #0a8, #086);
            border: 2px solid #0fa;
            color: #fff;
            border-radius: 10px;
            cursor: pointer;
        }
        
        #restartBtn:hover {
            background: linear-gradient(135deg, #0c9, #097);
        }
        
        /* ===== HIT MARKER ===== */
        #hitMarker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 4;
            opacity: 0;
        }
        
        #hitMarker.show { opacity: 1; }
        
        .hit-line {
            position: absolute;
            background: #f00;
            box-shadow: 0 0 5px #f00;
        }
        
        .hit-line.h {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .hit-line.v {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }
        
        /* ===== CONTROLS HELP ===== */
        #controlsHelp {
            position: absolute;
            bottom: 20px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 9px;
            z-index: 5;
            border: 1px solid rgba(0, 200, 255, 0.3);
            pointer-events: none;
            max-width: 200px;
        }
        
        .control-line {
            margin: 3px 0;
            color: #aac;
        }
        
        .control-key {
            color: #0ff;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Crosshair -->
        <div class="crosshair">
            <div class="crosshair-line h left"></div>
            <div class="crosshair-line h right"></div>
            <div class="crosshair-line v top"></div>
            <div class="crosshair-line v bottom"></div>
            <div class="crosshair-dot"></div>
        </div>
        
        <!-- Hit Marker -->
        <div id="hitMarker">
            <div class="hit-line h"></div>
            <div class="hit-line v"></div>
        </div>
        
        <div id="damageFlash"></div>
        <div id="levelIndicator">LEVEL 1</div>
        <div id="powerupNotification"></div>
        <div id="warningNotification"></div>
        
        <!-- Paused Overlay -->
        <div id="pausedOverlay">
            <div id="pausedText">‚è∏Ô∏è PAUSED</div>
        </div>
        
        <!-- UI Panel -->
        <div id="ui">
            <div style="font-weight: bold; color: #0ff; margin-bottom: 6px; font-size: 13px;">üéÆ G9 CS ARENA</div>
            <div class="stat-line">
                <span class="stat-label">‚ù§Ô∏è HP</span>
                <span class="stat-value" id="health">100</span>
            </div>
            <div class="bar-container">
                <div class="bar-fill health-fill" id="healthBar" style="width: 100%"></div>
            </div>
            <div class="stat-line" style="margin-top: 6px;">
                <span class="stat-label">üî´ Ammo</span>
                <span class="stat-value" id="ammo">30</span>
            </div>
            <div class="bar-container">
                <div class="bar-fill ammo-fill" id="ammoBar" style="width: 100%"></div>
            </div>
            <div class="stat-line" style="margin-top: 6px;">
                <span class="stat-label">‚≠ê Score</span>
                <span class="stat-value" id="score">0</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">üî• Streak</span>
                <span class="stat-value" id="streak">0</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">üìä Level</span>
                <span class="stat-value" id="level">1</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">üí£ Bombs</span>
                <span class="stat-value" id="bombCount">3</span>
            </div>
        </div>
        
        <!-- Stats Panel -->
        <div id="stats">
            <div class="stat-line">
                <span class="stat-label">Enemies</span>
                <span class="stat-value" id="enemyCount">0</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">‚úì Correct</span>
                <span class="stat-value" style="color: #0f0;" id="correct">0</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">‚úó Wrong</span>
                <span class="stat-value" style="color: #f44;" id="wrong">0</span>
            </div>
        </div>
        
        <!-- Active Powerups -->
        <div id="activePowerups">
            <div style="font-weight: bold; color: #fd0; margin-bottom: 4px;">‚ö° ACTIVE</div>
            <div id="powerupsList"></div>
        </div>
        
        <!-- Minimap -->
        <div id="minimap">
            <canvas id="minimapCanvas"></canvas>
        </div>
        
        <!-- Controls Help -->
        <div id="controlsHelp">
            <div style="font-weight: bold; color: #0ff; margin-bottom: 4px;">üéÆ CONTROLS</div>
            <div class="control-line"><span class="control-key">WASD/Arrows</span> - Move</div>
            <div class="control-line"><span class="control-key">Mouse</span> - Look</div>
            <div class="control-line"><span class="control-key">Click/Space</span> - Shoot</div>
            <div class="control-line"><span class="control-key">E</span> - Bomb</div>
            <div class="control-line"><span class="control-key">Q</span> - Question</div>
            <div class="control-line"><span class="control-key">ESC</span> - Pause</div>
        </div>
        
        <!-- Safe Room Indicator -->
        <div id="safeRoomIndicator">
            üè† SAFE ROOM
            <div class="subtitle">Press Q to answer questions safely!</div>
            <div class="warning">üö´ WEAPONS DISABLED</div>
        </div>
        
        <!-- Question Modal -->
        <div id="questionModal">
            <div id="questionContainer">
                <div id="questionCategory"></div>
                <div id="questionText"></div>
                <div id="optionsContainer"></div>
                <div id="feedback"></div>
            </div>
        </div>
        
        <!-- Game Over -->
        <div id="gameMessage">
            <div id="gameOverText"></div>
            <button id="restartBtn" onclick="location.reload()">üîÑ PLAY AGAIN</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ===== G9 COMPUTER SCIENCE QUESTION POOL =====
        const QUESTION_POOL = [
            // Multiple Choice from PDF
            { q: "What is the primary goal of automation in industries like manufacturing?", a: ["To improve efficiency and productivity by reducing manual labor", "To increase the need for human intervention", "To decrease the precision and accuracy of production processes", "To limit the flexibility of production and product design"], c: 0, cat: "Automation" },
            { q: "Which of the following is NOT a common application of robotics in automation?", a: ["Customer service interactions", "Assembly line tasks", "Welding and painting", "Material handling and packaging"], c: 0, cat: "Robotics" },
            { q: "What is the role of sensors in automated systems?", a: ["To collect data about the environment and provide feedback to the system", "To control the movement of robots", "To process data and make decisions without human intervention", "To display information to human operators"], c: 0, cat: "Automation" },
            { q: "What is an advantage of using Computer Numerical Control (CNC) machines in manufacturing?", a: ["Increased precision and accuracy in producing complex parts", "Increased reliance on manual labor", "Reduced production speed and efficiency", "Limited flexibility in adapting to design changes"], c: 0, cat: "Manufacturing" },
            { q: "What is a potential impact of automation on the workforce?", a: ["Job displacement in certain sectors due to reduced need for human labor", "Increased demand for low-skilled labor", "Decreased productivity in industries", "No significant impact on employment patterns"], c: 0, cat: "Automation Impact" },
            { q: "What is a key benefit of using Programmable Logic Controllers (PLCs) in automation?", a: ["They can automate complex processes by controlling and monitoring machinery", "They require constant human intervention to function", "They are inflexible and cannot be reprogrammed for different tasks", "They are only suitable for simple, repetitive tasks"], c: 0, cat: "PLCs" },
            { q: "What is a concern related to the increasing use of automation in various industries?", a: ["Ethical considerations and potential impact on employment", "Reduced efficiency and productivity", "Increased costs associated with implementing automation", "Limited potential for innovation and technological advancements"], c: 0, cat: "Ethics" },
            { q: "How can automation benefit small and medium-sized enterprises (SMEs)?", a: ["By improving efficiency, productivity, and product quality, even with limited resources", "By increasing operating costs and reducing competitiveness", "By limiting production capacity and flexibility", "By solely relying on manual labor and avoiding any technological advancements"], c: 0, cat: "SMEs" },
            { q: "What is an example of automation in everyday life?", a: ["Using a self-checkout kiosk at a grocery store", "Using a manual typewriter", "Sending a telegram", "Listening to vinyl records"], c: 0, cat: "Everyday Automation" },
            { q: "Which of the following pseudocode statements correctly represents a conditional statement that checks if a variable age is greater than or equal to 18?", a: ["IF age >= 18 THEN", "IF age > 18 THEN", "INPUT age >= 18", "OUTPUT age > 18"], c: 0, cat: "Pseudocode" },
            
            // Additional questions based on fill-in-the-blank
            { q: "What do flowcharts NOT directly translate into?", a: ["Executable code", "Visual diagrams", "Pseudocode", "Written instructions"], c: 0, cat: "SDLC" },
            { q: "What is the main goal of the Maintenance stage in the SDLC?", a: ["To ensure the program continues to function correctly and meet user needs", "To write the initial code", "To design the user interface", "To analyze requirements"], c: 0, cat: "SDLC" },
            { q: "Which conditional statement is used in pseudocode?", a: ["If...Then...Else", "Switch...Case", "While...Do", "For...Next"], c: 0, cat: "Pseudocode" },
            { q: "A loop structure in a flowchart represents:", a: ["A set of instructions that are repeated multiple times", "A single decision point", "The end of the program", "Input from the user"], c: 0, cat: "Flowcharts" },
            { q: "What is the first stage in the Software Development Lifecycle (SDLC)?", a: ["Analysis", "Design", "Implementation", "Testing"], c: 0, cat: "SDLC" },
            
            // Additional G9 CS topics
            { q: "What does AI stand for?", a: ["Artificial Intelligence", "Automated Integration", "Advanced Input", "Application Interface"], c: 0, cat: "AI" },
            { q: "Which technology is used to create extremely small machines and materials at the molecular level?", a: ["Nanotechnology", "Biotechnology", "Robotics", "Automation"], c: 0, cat: "Emerging Tech" },
            { q: "What is the purpose of the testing stage in SDLC?", a: ["To identify and fix bugs before deployment", "To write the code", "To gather requirements", "To train users"], c: 0, cat: "SDLC" },
            { q: "Documentation in SDLC is important because:", a: ["It helps users and developers understand how to use and maintain the software", "It makes the software run faster", "It reduces the file size", "It automatically fixes bugs"], c: 0, cat: "SDLC" },
            { q: "What type of robot is commonly used in manufacturing assembly lines?", a: ["Industrial robots", "Humanoid robots", "Nano robots", "Flying drones"], c: 0, cat: "Robotics" },
            
            // More challenging questions
            { q: "Which of these is a potential benefit of AI in healthcare?", a: ["Improved diagnosis accuracy", "Reduced need for doctors", "Elimination of all diseases", "Automatic patient recovery"], c: 0, cat: "AI Applications" },
            { q: "What is biotechnology primarily concerned with?", a: ["Using biological processes for industrial and medical purposes", "Building computer networks", "Creating artificial intelligence", "Designing robots"], c: 0, cat: "Biotechnology" },
            { q: "In the SDLC, what comes after the design phase?", a: ["Implementation", "Analysis", "Testing", "Maintenance"], c: 0, cat: "SDLC" },
            { q: "What is a potential ethical concern with facial recognition technology?", a: ["Privacy violations and surveillance concerns", "Too expensive to implement", "Requires too much electricity", "Only works in daylight"], c: 0, cat: "Ethics" },
            { q: "Which programming concept allows code to make decisions?", a: ["Conditional statements", "Variables", "Comments", "Functions"], c: 0, cat: "Programming" },
            { q: "What is the main purpose of a loop in programming?", a: ["To repeat a set of instructions multiple times", "To make the program run faster", "To delete variables", "To print output"], c: 0, cat: "Programming" },
            { q: "Which stage of SDLC involves gathering information about what the software needs to do?", a: ["Analysis", "Implementation", "Testing", "Deployment"], c: 0, cat: "SDLC" },
            { q: "What is machine learning?", a: ["A type of AI where systems learn from data without explicit programming", "A way to lift heavy machinery", "A method to clean computer parts", "A type of robot"], c: 0, cat: "AI" },
            { q: "Which automation technology is used in modern cars for safety?", a: ["Anti-lock braking systems (ABS)", "Manual transmission", "Cassette players", "Hand-crank windows"], c: 0, cat: "Automation" },
            { q: "What does CNC stand for in manufacturing?", a: ["Computer Numerical Control", "Central Network Computer", "Controlled Numeric Calculation", "Coded Number Conversion"], c: 0, cat: "Manufacturing" }
        ];

        function shuffleArray(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }
        
        let shuffledQuestions = shuffleArray([...QUESTION_POOL]);
        let questionIndex = 0;

        // ===== GAME STATE =====
        const gameState = {
            health: 100, maxHealth: 100,
            ammo: 30, maxAmmo: 60,
            bombs: 3, maxBombs: 5,
            score: 0, streak: 0,
            correct: 0, wrong: 0,
            level: 1,
            activePowerups: [],
            questionActive: false,
            paused: false,
            currentQuestion: null,
            gameOver: false,
            pauseStartTime: 0,
            inSafeRoom: false,
            safeRoomMode: false,
            // Powerup effects
            shieldActive: false,
            speedMultiplier: 1,
            damageMultiplier: 1,
            fireRateMultiplier: 1,
            magnetActive: false,
            vampireActive: false,
            piercingActive: false,
            titanMode: false,
            blackHoleActive: false,
            godBeamActive: false,
            timeFreezeActive: false,
            tornadoActive: false,
            lightningChainActive: false,
            autoAimActive: false,
            ghostModeActive: false,
            deathAuraActive: false
        };

        // ===== KEYBOARD STATE =====
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            keys[e.code] = true; // Also track by code for arrow keys
            
            if (e.key.toLowerCase() === 'e') dropBomb();
            if (e.key.toLowerCase() === 'q') showQuestion(gameState.inSafeRoom);
            if (e.key === 'Escape') {
                if (!gameState.questionActive) {
                    gameState.paused = !gameState.paused;
                    document.getElementById('pausedOverlay').classList.toggle('show', gameState.paused);
                    if (!gameState.paused) animate();
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            keys[e.code] = false; // Also clear by code
        });

        // ===== MOUSE STATE =====
        let mouseLocked = false;
        const euler = new THREE.Euler(0, 0, 0, 'YXZ');
        const PI_2 = Math.PI / 2;
        
        document.addEventListener('click', () => {
            if (!mouseLocked && !gameState.questionActive) {
                renderer.domElement.requestPointerLock();
            }
            if (mouseLocked && !gameState.questionActive && !gameState.paused) {
                createProjectile();
            }
        });
        
        document.addEventListener('pointerlockchange', () => {
            mouseLocked = document.pointerLockElement === renderer.domElement;
            if (mouseLocked) {
                document.body.classList.add('pointer-locked');
            } else {
                document.body.classList.remove('pointer-locked');
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (mouseLocked) {
                const sensitivity = 0.002;
                euler.setFromQuaternion(camera.quaternion);
                euler.y -= e.movementX * sensitivity;
                euler.x -= e.movementY * sensitivity;
                euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
                camera.quaternion.setFromEuler(euler);
            }
        });

        // ===== THREE.JS SETUP =====
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.FogExp2(0x050510, 0.015);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('gameContainer').appendChild(renderer.domElement);
        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.top = '0';
        renderer.domElement.style.left = '0';
        renderer.domElement.style.zIndex = '1';

        // ===== LIGHTING =====
        const ambientLight = new THREE.AmbientLight(0x6644aa, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xff00ff, 0.8);
        directionalLight.position.set(30, 50, 30);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        const pointLight1 = new THREE.PointLight(0x00ffff, 0.6, 60);
        pointLight1.position.set(-25, 10, -25);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xff0088, 0.6, 60);
        pointLight2.position.set(25, 10, 25);
        scene.add(pointLight2);

        // ===== LEVEL GENERATION =====
        const levelObjects = [];
        const traps = [];
        const ARENA_SIZE = 70;
        
        const SAFE_ROOM = {
            x: -ARENA_SIZE + 20,
            z: 0,
            width: 18,
            depth: 18,
            height: 8
        };

        let gridHelper;

        function generateLevel(level) {
            levelObjects.forEach(obj => scene.remove(obj));
            levelObjects.length = 0;
            traps.forEach(t => { scene.remove(t.mesh); scene.remove(t.spikes); });
            traps.length = 0;

            const groundGeom = new THREE.PlaneGeometry(ARENA_SIZE * 2, ARENA_SIZE * 2, 40, 40);
            const groundMat = new THREE.MeshStandardMaterial({ 
                color: 0x0a0a1a, 
                roughness: 0.4,
                metalness: 0.6
            });
            const ground = new THREE.Mesh(groundGeom, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            levelObjects.push(ground);

            if (gridHelper) scene.remove(gridHelper);
            gridHelper = new THREE.GridHelper(ARENA_SIZE * 2, 60, 0xff00ff, 0x220044);
            gridHelper.position.y = 0.05;
            scene.add(gridHelper);
            levelObjects.push(gridHelper);

            const wallMat = new THREE.MeshStandardMaterial({ color: 0x220044, emissive: 0x220066, emissiveIntensity: 0.4, metalness: 0.8, roughness: 0.2 });
            [
                { x: 0, z: -ARENA_SIZE, ry: 0 },
                { x: 0, z: ARENA_SIZE, ry: 0 },
                { x: -ARENA_SIZE, z: 0, ry: Math.PI/2 },
                { x: ARENA_SIZE, z: 0, ry: Math.PI/2 }
            ].forEach(p => {
                const wall = new THREE.Mesh(new THREE.BoxGeometry(ARENA_SIZE * 2, 12, 2), wallMat);
                wall.position.set(p.x, 6, p.z);
                wall.rotation.y = p.ry;
                wall.castShadow = true;
                scene.add(wall);
                levelObjects.push(wall);
            });

            const obsMat = new THREE.MeshStandardMaterial({ color: 0x445566, roughness: 0.3, metalness: 0.7 });
            const obsEmissive = new THREE.MeshStandardMaterial({ color: 0x000, emissive: 0x00ffff, emissiveIntensity: 0.8 });
            
            for (let i = 0; i < 6 + level * 2; i++) {
                const s = 3 + Math.random() * 4;
                const h = 4 + Math.random() * 8;
                const geom = [
                    new THREE.BoxGeometry(s, h, s),
                    new THREE.CylinderGeometry(s/2, s/2, h, 8),
                    new THREE.ConeGeometry(s/2, h, 6)
                ][Math.floor(Math.random() * 3)];
                
                const obs = new THREE.Mesh(geom, obsMat);
                obs.position.set((Math.random() - 0.5) * (ARENA_SIZE - 20), h/2, (Math.random() - 0.5) * (ARENA_SIZE - 20));
                
                if (Math.random() > 0.5) {
                    const trim = new THREE.Mesh(new THREE.BoxGeometry(s + 0.1, 0.2, s + 0.1), obsEmissive);
                    trim.position.y = Math.random() * h/2;
                    obs.add(trim);
                }

                obs.castShadow = true;
                scene.add(obs);
                levelObjects.push(obs);
            }

            for (let i = 0; i < Math.min(level + 1, 6); i++) createTrap();

            const pillarMat = new THREE.MeshStandardMaterial({ color: 0x00ffaa, emissive: 0x00ff88, emissiveIntensity: 0.8, transparent: true, opacity: 0.8 });
            for (let i = 0; i < 6; i++) {
                const pillar = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 20, 8), pillarMat);
                const angle = (i / 6) * Math.PI * 2;
                pillar.position.set(Math.cos(angle) * (ARENA_SIZE - 15), 10, Math.sin(angle) * (ARENA_SIZE - 15));
                pillar.castShadow = true;
                scene.add(pillar);
                levelObjects.push(pillar);
            }
            
            createSafeRoom();
            createDust();
        }
        
        let dustSystem;
        function createDust() {
            if (dustSystem) scene.remove(dustSystem);
            const geom = new THREE.BufferGeometry();
            const counts = 300; // Reduced from 1000
            const positions = new Float32Array(counts * 3);
            for(let i=0; i<counts*3; i+=3) {
                positions[i] = (Math.random() - 0.5) * ARENA_SIZE * 2;
                positions[i+1] = Math.random() * 20;
                positions[i+2] = (Math.random() - 0.5) * ARENA_SIZE * 2;
            }
            geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0x88aaff, size: 0.2, transparent: true, opacity: 0.5 });
            dustSystem = new THREE.Points(geom, mat);
            scene.add(dustSystem);
        }

        function createSafeRoom() {
            const sr = SAFE_ROOM;
            
            const floorMat = new THREE.MeshStandardMaterial({ 
                color: 0x004422, 
                emissive: 0x00ff66, 
                emissiveIntensity: 0.2,
                roughness: 0.3
            });
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(sr.width, sr.depth), floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set(sr.x, 0.1, sr.z);
            scene.add(floor);
            levelObjects.push(floor);
            
            const wallMat = new THREE.MeshStandardMaterial({ 
                color: 0x00aa66, 
                emissive: 0x00ff88, 
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.4
            });
            
            const backWall = new THREE.Mesh(new THREE.BoxGeometry(sr.width, sr.height, 0.5), wallMat);
            backWall.position.set(sr.x, sr.height / 2, sr.z - sr.depth / 2);
            scene.add(backWall);
            levelObjects.push(backWall);
            
            const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.5, sr.height, sr.depth), wallMat);
            leftWall.position.set(sr.x - sr.width / 2, sr.height / 2, sr.z);
            scene.add(leftWall);
            levelObjects.push(leftWall);
            
            const rightWallTop = new THREE.Mesh(new THREE.BoxGeometry(0.5, sr.height - 4, sr.depth), wallMat);
            rightWallTop.position.set(sr.x + sr.width / 2, sr.height - 2, sr.z);
            scene.add(rightWallTop);
            levelObjects.push(rightWallTop);
            
            const frontWallLeft = new THREE.Mesh(new THREE.BoxGeometry((sr.width - 6) / 2, sr.height, 0.5), wallMat);
            frontWallLeft.position.set(sr.x - sr.width / 4 - 1.5, sr.height / 2, sr.z + sr.depth / 2);
            scene.add(frontWallLeft);
            levelObjects.push(frontWallLeft);
            
            const frontWallRight = new THREE.Mesh(new THREE.BoxGeometry((sr.width - 6) / 2, sr.height, 0.5), wallMat);
            frontWallRight.position.set(sr.x + sr.width / 4 + 1.5, sr.height / 2, sr.z + sr.depth / 2);
            scene.add(frontWallRight);
            levelObjects.push(frontWallRight);
            
            const signMat = new THREE.MeshStandardMaterial({ 
                color: 0x00ff88, 
                emissive: 0x00ff88, 
                emissiveIntensity: 1
            });
            const sign = new THREE.Mesh(new THREE.BoxGeometry(4, 1, 0.2), signMat);
            sign.position.set(sr.x, sr.height + 1, sr.z + sr.depth / 2);
            scene.add(sign);
            levelObjects.push(sign);
            
            const safeLight = new THREE.PointLight(0x00ff88, 1, 25);
            safeLight.position.set(sr.x, 5, sr.z);
            scene.add(safeLight);
            levelObjects.push(safeLight);
        }

        function createTrap() {
            const trapMat = new THREE.MeshBasicMaterial({ color: 0xff0044, transparent: true, opacity: 0.4 });
            const trap = new THREE.Mesh(new THREE.CircleGeometry(3.5, 16), trapMat);
            trap.rotation.x = -Math.PI / 2;
            trap.position.set((Math.random() - 0.5) * (ARENA_SIZE - 25), 0.1, (Math.random() - 0.5) * (ARENA_SIZE - 25));
            
            const spikes = new THREE.Group();
            const spikeMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xaa0000, emissiveIntensity: 0.5 });
            for (let i = 0; i < 6; i++) {
                const spike = new THREE.Mesh(new THREE.ConeGeometry(0.25, 1.2, 4), spikeMat);
                const angle = (i / 6) * Math.PI * 2;
                spike.position.set(Math.cos(angle) * 1.8, 0, Math.sin(angle) * 1.8);
                spikes.add(spike);
            }
            spikes.position.copy(trap.position);
            spikes.position.y = -1;
            
            scene.add(trap);
            scene.add(spikes);
            traps.push({ mesh: trap, spikes, active: false, timer: 0, cooldown: 0 });
        }

        function updateTraps() {
            traps.forEach(trap => {
                const dist = Math.sqrt(
                    Math.pow(camera.position.x - trap.mesh.position.x, 2) +
                    Math.pow(camera.position.z - trap.mesh.position.z, 2)
                );
                trap.timer++;
                
                if (dist < 3.5 && trap.cooldown <= 0) {
                    trap.active = true;
                    trap.cooldown = 180;
                }

                if (trap.active) {
                    trap.spikes.position.y = Math.min(trap.spikes.position.y + 0.25, 0.6);
                    if (trap.spikes.position.y >= 0.5 && dist < 3.5 && !gameState.shieldActive && !gameState.titanMode) {
                        gameState.health -= 0.8;
                        showDamageFlash();
                    }
                    if (trap.timer % 50 === 0) trap.active = false;
                } else {
                    trap.spikes.position.y = Math.max(trap.spikes.position.y - 0.15, -1);
                }

                if (trap.cooldown > 0) trap.cooldown--;
                trap.mesh.material.opacity = 0.3 + Math.sin(trap.timer * 0.1) * 0.15;
            });
        }

        // ===== ENEMY SYSTEM =====
        const enemies = [];
        const ENEMY_TYPES = {
            BASIC: { name: 'Basic', color: 0xff3333, health: 15, speed: 0.035, damage: 2, size: { w: 1.2, h: 2.2, d: 1.2 }, score: 100, hitRadius: 1.8 },
            FAST: { name: 'Fast', color: 0xffff00, health: 8, speed: 0.08, damage: 1, size: { w: 0.8, h: 1.6, d: 0.8 }, score: 150, hitRadius: 1.3 },
            TANK: { name: 'Tank', color: 0x8844ff, health: 45, speed: 0.018, damage: 6, size: { w: 2, h: 2.8, d: 2 }, score: 250, hitRadius: 2.5 },
            RANGED: { name: 'Ranged', color: 0x00ff88, health: 12, speed: 0.022, damage: 4, size: { w: 1.1, h: 2.4, d: 1.1 }, score: 200, ranged: true, fireRate: 100, hitRadius: 1.7 },
            KAMIKAZE: { name: 'Kamikaze', color: 0xff0000, health: 5, speed: 0.12, damage: 25, size: { w: 0.7, h: 0.7, d: 0.7 }, score: 300, kamikaze: true, hitRadius: 1.0 },
            BOSS: { name: 'BOSS', color: 0xff00ff, health: 200, speed: 0.025, damage: 15, size: { w: 4, h: 5, d: 4 }, score: 2000, hitRadius: 5, isBoss: true, fireRate: 60 }
        };

        function createEnemy(type = null) {
            if (!type) {
                const rand = Math.random();
                const lvl = gameState.level;
                if (rand < 0.30) type = ENEMY_TYPES.BASIC;
                else if (rand < 0.50) type = ENEMY_TYPES.FAST;
                else if (rand < 0.65 && lvl >= 2) type = ENEMY_TYPES.TANK;
                else if (rand < 0.80 && lvl >= 2) type = ENEMY_TYPES.RANGED;
                else if (lvl >= 3) type = ENEMY_TYPES.KAMIKAZE;
                else type = ENEMY_TYPES.BASIC;
            }

            const geom = type.kamikaze ? new THREE.SphereGeometry(type.size.w/2, 16, 16) : new THREE.BoxGeometry(type.size.w, type.size.h, type.size.d);
            const mat = new THREE.MeshStandardMaterial({ 
                color: type.color, 
                emissive: type.color, 
                emissiveIntensity: type.isBoss ? 0.8 : 0.4
            });
            const enemy = new THREE.Mesh(geom, mat);
            enemy.castShadow = true;

            const angle = Math.random() * Math.PI * 2;
            enemy.position.set(Math.cos(angle) * (ARENA_SIZE - 8), type.size.h / 2, Math.sin(angle) * (ARENA_SIZE - 8));

            enemy.enemyType = type;
            enemy.health = type.health;
            enemy.maxHealth = type.health;
            enemy.speed = type.speed;
            enemy.damage = type.damage;
            enemy.hitRadius = type.hitRadius;
            enemy.hasDropped = false;
            enemy.fireTimer = 0;

            const hbMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const healthBar = new THREE.Mesh(new THREE.PlaneGeometry(type.isBoss ? 5 : 2.5, type.isBoss ? 0.4 : 0.25), hbMat);
            healthBar.position.y = type.size.h / 2 + (type.isBoss ? 1.2 : 0.6);
            enemy.add(healthBar);
            enemy.healthBar = healthBar;
            
            // Boss crown
            if (type.isBoss) {
                const crownMat = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1 });
                const crown = new THREE.Mesh(new THREE.ConeGeometry(1, 2, 6), crownMat);
                crown.position.y = type.size.h / 2 + 2;
                enemy.add(crown);
                enemy.crown = crown;
            }

            enemy.boundingBox = new THREE.Box3();

            scene.add(enemy);
            enemies.push(enemy);
        }

        const enemyProjectiles = [];

        function updateEnemies() {
            enemies.forEach((enemy, idx) => {
                enemy.boundingBox.setFromObject(enemy);
                
                // Titan Mode Stomp
                if (gameState.titanMode) {
                    const distToPlayer = enemy.position.distanceTo(new THREE.Vector3(camera.position.x, enemy.position.y, camera.position.z));
                    if (distToPlayer < 4) {
                        enemy.health = 0;
                        createParticleBurst(enemy.position, 0xff0000, 8);
                    }
                }
                
                // Death Aura - damages enemies within 10 units
                if (gameState.deathAuraActive) {
                    const distToPlayer = enemy.position.distanceTo(camera.position);
                    if (distToPlayer < 10) {
                        enemy.health -= 0.5;
                        if (Math.random() > 0.95) createParticleBurst(enemy.position, 0x880088, 3);
                    }
                }

                if (enemy.health <= 0) {
                    createExplosion(enemy.position, enemy.enemyType.color, enemy.enemyType.isBoss ? 20 : 12);
                    if (!enemy.hasDropped) {
                        const dropChance = enemy.enemyType.isBoss ? 1 : 0.6;
                        if (Math.random() > (1 - dropChance)) spawnPowerup(enemy.position);
                        if (enemy.enemyType.isBoss) {
                            // Boss drops multiple powerups
                            for (let i = 0; i < 3; i++) {
                                setTimeout(() => spawnPowerup(enemy.position.clone().add(new THREE.Vector3((Math.random()-0.5)*5, 0, (Math.random()-0.5)*5))), i * 200);
                            }
                        }
                        enemy.hasDropped = true;
                    }
                    scene.remove(enemy);
                    enemies.splice(idx, 1);
                    gameState.score += enemy.enemyType.score * gameState.damageMultiplier;
                    
                    if (gameState.vampireActive) {
                        gameState.health = Math.min(gameState.maxHealth, gameState.health + 5);
                    }
                    return;
                }

                const hp = enemy.health / enemy.maxHealth;
                enemy.healthBar.scale.x = hp;
                enemy.healthBar.material.color.setHex(hp > 0.5 ? 0x00ff00 : (hp > 0.25 ? 0xffff00 : 0xff0000));
                enemy.healthBar.lookAt(camera.position);

                // Time Freeze - enemies don't move
                if (gameState.timeFreezeActive) {
                    enemy.material.emissiveIntensity = 0.1;
                    return;
                }
                enemy.material.emissiveIntensity = enemy.enemyType.isBoss ? 0.8 : 0.4;

                const dir = new THREE.Vector3().subVectors(camera.position, enemy.position);
                dir.y = 0;
                
                const nextPos = enemy.position.clone().addScaledVector(dir.clone().normalize(), enemy.speed);
                const inSafeZone = isInSafeRoom(nextPos);
                
                // Black Hole Pull
                if (gameState.blackHoleActive && blackHoleMesh) {
                    const pullDir = new THREE.Vector3().subVectors(blackHoleMesh.position, enemy.position).normalize();
                    enemy.position.addScaledVector(pullDir, 0.3);
                    
                    if (enemy.position.distanceTo(blackHoleMesh.position) < 2) {
                        enemy.health -= 5;
                    }
                }
                
                // Tornado Pull
                if (gameState.tornadoActive && tornadoMesh) {
                    const pullDir = new THREE.Vector3().subVectors(tornadoMesh.position, enemy.position).normalize();
                    enemy.position.addScaledVector(pullDir, 0.2);
                    enemy.position.y += Math.sin(Date.now() * 0.01) * 0.1; // Lift up
                    
                    if (enemy.position.distanceTo(tornadoMesh.position) < 4) {
                        enemy.health -= 0.3;
                        enemy.rotation.y += 0.2; // Spin them
                    }
                }

                if (enemy.enemyType.ranged || enemy.enemyType.isBoss) {
                    const dist = dir.length();
                    if (dist < 12) dir.negate();
                    else if (dist > 20 && !inSafeZone) {
                        dir.normalize();
                        enemy.position.addScaledVector(dir, enemy.speed);
                    }
                    enemy.fireTimer++;
                    if (enemy.fireTimer >= enemy.enemyType.fireRate && !gameState.inSafeRoom) {
                        enemy.fireTimer = 0;
                        createEnemyProjectile(enemy.position.clone(), camera.position.clone());
                        // Boss fires 3 projectiles
                        if (enemy.enemyType.isBoss) {
                            setTimeout(() => createEnemyProjectile(enemy.position.clone(), camera.position.clone()), 100);
                            setTimeout(() => createEnemyProjectile(enemy.position.clone(), camera.position.clone()), 200);
                        }
                    }
                } else if (enemy.enemyType.kamikaze) {
                    if (!inSafeZone) {
                        dir.normalize();
                        enemy.position.addScaledVector(dir, enemy.speed);
                        enemy.material.emissiveIntensity = 0.5 + Math.sin(Date.now() * 0.02) * 0.5;
                    }
                } else {
                    if (!inSafeZone) {
                        dir.normalize();
                        enemy.position.addScaledVector(dir, enemy.speed);
                    } else {
                        const avoidDir = new THREE.Vector3(enemy.position.x - SAFE_ROOM.x, 0, enemy.position.z - SAFE_ROOM.z).normalize();
                        enemy.position.addScaledVector(avoidDir, enemy.speed * 0.5);
                    }
                }

                if (!gameState.inSafeRoom && enemy.position.distanceTo(camera.position) < enemy.hitRadius + 0.8) {
                    if (enemy.enemyType.kamikaze) {
                        enemy.health = 0;
                        createExplosion(enemy.position, 0xff0000, 25);
                        if (!gameState.shieldActive && !gameState.titanMode && !gameState.ghostModeActive) {
                            gameState.health -= enemy.damage;
                            showDamageFlash();
                        }
                    } else if (!gameState.shieldActive && !gameState.titanMode && !gameState.ghostModeActive) {
                        gameState.health -= enemy.damage * 0.08;
                        showDamageFlash();
                    }
                    
                    if (gameState.reflectActive) enemy.health -= 3;
                }

                enemy.rotation.y += enemy.enemyType.isBoss ? 0.02 : 0.015;
                if (enemy.crown) enemy.crown.rotation.y += 0.1;
            });

            enemyProjectiles.forEach((proj, idx) => {
                proj.position.add(proj.velocity);
                proj.life--;

                if (proj.life <= 0) {
                    scene.remove(proj);
                    enemyProjectiles.splice(idx, 1);
                    return;
                }

                if (isInSafeRoom(proj.position)) {
                    createParticleBurst(proj.position, 0x00ff88, 8);
                    scene.remove(proj);
                    enemyProjectiles.splice(idx, 1);
                    return;
                }

                if (proj.position.distanceTo(camera.position) < 1.2) {
                    if (!gameState.shieldActive && !gameState.inSafeRoom && !gameState.titanMode) {
                        gameState.health -= 6;
                        showDamageFlash();
                    }
                    if (gameState.reflectActive) {
                        proj.velocity.negate();
                        proj.life = 100;
                        proj.reflected = true;
                    } else {
                        scene.remove(proj);
                        enemyProjectiles.splice(idx, 1);
                    }
                }
                
                if (proj.reflected) {
                    enemies.forEach(enemy => {
                        if (proj.position.distanceTo(enemy.position) < enemy.hitRadius) {
                            enemy.health -= 10;
                            scene.remove(proj);
                            enemyProjectiles.splice(idx, 1);
                        }
                    });
                }
            });

            const maxEnemies = 4 + gameState.level * 2;
            if (enemies.length < maxEnemies && Math.random() > 0.985) {
                createEnemy();
            }
            
            // Spawn boss every 3 levels
            const bossExists = enemies.some(e => e.enemyType.isBoss);
            if (!bossExists && gameState.level % 3 === 0 && gameState.level > 0 && Math.random() > 0.995) {
                createEnemy(ENEMY_TYPES.BOSS);
                showPowerupNotification("‚ö†Ô∏è BOSS SPAWNED!");
            }
        }
        
        function isInSafeRoom(pos) {
            const sr = SAFE_ROOM;
            return pos.x > sr.x - sr.width / 2 && 
                   pos.x < sr.x + sr.width / 2 && 
                   pos.z > sr.z - sr.depth / 2 && 
                   pos.z < sr.z + sr.depth / 2;
        }
        
        function updateSafeRoomStatus() {
            const wasInSafeRoom = gameState.inSafeRoom;
            gameState.inSafeRoom = isInSafeRoom(camera.position);
            
            const indicator = document.getElementById('safeRoomIndicator');
            
            if (gameState.inSafeRoom) {
                indicator.classList.add('show');
            } else {
                indicator.classList.remove('show');
            }
        }

        function createEnemyProjectile(from, to) {
            const proj = new THREE.Mesh(
                new THREE.SphereGeometry(0.35, 8, 8),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            proj.position.copy(from);
            proj.position.y = 1.5;
            proj.velocity = new THREE.Vector3().subVectors(to, from).normalize().multiplyScalar(0.35);
            proj.life = 150;
            proj.reflected = false;
            scene.add(proj);
            enemyProjectiles.push(proj);
        }

        // ===== POWERUP SYSTEM =====
        const powerupObjects = [];
        const POWERUP_TYPES = [
            // Essentials
            { name: "‚ù§Ô∏è Health +40", color: 0xff4444, rarity: 1, effect: () => { gameState.health = Math.min(gameState.maxHealth, gameState.health + 40); } },
            { name: "üî´ Ammo +20", color: 0xffff00, rarity: 1, effect: () => { gameState.ammo = Math.min(gameState.maxAmmo, gameState.ammo + 20); } },
            
            // Defense
            { name: "üõ°Ô∏è Shield", color: 0x4488ff, rarity: 0.6, duration: 10000, effect: () => { 
                gameState.shieldActive = true; addTimedPowerup("üõ°Ô∏è Shield", 10000, () => { gameState.shieldActive = false; }); }},
            
            // CRAZY POWERUPS
            { name: "üåå BLACK HOLE", color: 0xaa00ff, rarity: 0.15, duration: 8000, effect: () => {
                activateBlackHole();
            }},
            { name: "üî± TITAN MODE", color: 0xffaa00, rarity: 0.1, duration: 15000, effect: () => {
                gameState.titanMode = true;
                camera.position.y = 8;
                addTimedPowerup("üî± TITAN", 15000, () => { 
                    gameState.titanMode = false; 
                    camera.position.y = 3; 
                });
            }},
            { name: "‚ú® GOD BEAM", color: 0x00ffff, rarity: 0.2, duration: 6000, effect: () => {
                gameState.godBeamActive = true;
                addTimedPowerup("‚ú® BEAM", 6000, () => { gameState.godBeamActive = false; });
            }},
            { name: "‚è∞ TIME FREEZE", color: 0x88ffff, rarity: 0.15, duration: 8000, effect: () => {
                gameState.timeFreezeActive = true;
                addTimedPowerup("‚è∞ FREEZE", 8000, () => { gameState.timeFreezeActive = false; });
            }},
            { name: "üå™Ô∏è TORNADO", color: 0xaaffaa, rarity: 0.12, duration: 10000, effect: () => {
                activateTornado();
            }},
            { name: "‚ö° LIGHTNING CHAIN", color: 0xffff88, rarity: 0.18, duration: 12000, effect: () => {
                gameState.lightningChainActive = true;
                addTimedPowerup("‚ö° CHAIN", 12000, () => { gameState.lightningChainActive = false; });
            }},
            { name: "üéØ AUTO-AIM", color: 0xff88ff, rarity: 0.2, duration: 15000, effect: () => {
                gameState.autoAimActive = true;
                addTimedPowerup("üéØ AIM", 15000, () => { gameState.autoAimActive = false; });
            }},
            { name: "üëª GHOST MODE", color: 0xccccff, rarity: 0.15, duration: 10000, effect: () => {
                gameState.ghostModeActive = true;
                addTimedPowerup("üëª GHOST", 10000, () => { gameState.ghostModeActive = false; });
            }},
            { name: "üíÄ DEATH AURA", color: 0x880088, rarity: 0.1, duration: 8000, effect: () => {
                gameState.deathAuraActive = true;
                addTimedPowerup("üíÄ AURA", 8000, () => { gameState.deathAuraActive = false; });
            }},
            { name: "üöÄ ORBITAL STRIKE", color: 0xff0088, rarity: 0.08, effect: () => {
                activateOrbitalStrike();
            }},
            
            // Enhanced Offense
            { name: "‚ö° Speed x2", color: 0x00ffff, rarity: 0.7, duration: 12000, effect: () => {
                gameState.speedMultiplier = 2; addTimedPowerup("‚ö° Speed", 12000, () => { gameState.speedMultiplier = 1; }); }},
            { name: "üí• Damage x2", color: 0xff8800, rarity: 0.7, duration: 15000, effect: () => {
                gameState.damageMultiplier = 2; addTimedPowerup("üí• Damage", 15000, () => { gameState.damageMultiplier = 1; }); }},
            { name: "üî• Rapid Fire", color: 0xff4400, rarity: 0.6, duration: 10000, effect: () => {
                gameState.fireRateMultiplier = 4; addTimedPowerup("üî• Rapid", 10000, () => { gameState.fireRateMultiplier = 1; }); }},
            
            // Special
            { name: "üß≤ Magnet", color: 0xffdd00, rarity: 0.5, duration: 15000, effect: () => {
                gameState.magnetActive = true; addTimedPowerup("üß≤ Magnet", 15000, () => { gameState.magnetActive = false; }); }},
            { name: "üßõ Vampire", color: 0xaa0055, rarity: 0.4, duration: 12000, effect: () => {
                gameState.vampireActive = true; addTimedPowerup("üßõ Vampire", 12000, () => { gameState.vampireActive = false; }); }},
            { name: "üí£ Bomb +2", color: 0xff6600, rarity: 0.6, effect: () => { gameState.bombs = Math.min(gameState.maxBombs, gameState.bombs + 2); } }
        ];
        
        let blackHoleMesh = null;
        let tornadoMesh = null;
        
        function activateBlackHole() {
            gameState.blackHoleActive = true;
            blackHoleMesh = new THREE.Mesh(
                new THREE.SphereGeometry(1, 32, 32),
                new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            const disk = new THREE.Mesh(
                new THREE.RingGeometry(2, 4, 32),
                new THREE.MeshBasicMaterial({ color: 0xaa00ff, side: THREE.DoubleSide, transparent: true, opacity: 0.8 })
            );
            disk.rotation.x = Math.PI / 2;
            blackHoleMesh.add(disk);
            
            blackHoleMesh.position.copy(camera.position).add(new THREE.Vector3(0, 5, -15).applyQuaternion(camera.quaternion));
            scene.add(blackHoleMesh);
            
            addTimedPowerup("üåå Singularity", 8000, () => { 
                gameState.blackHoleActive = false; 
                scene.remove(blackHoleMesh); 
                blackHoleMesh = null;
            });
        }
        
        function activateTornado() {
            gameState.tornadoActive = true;
            tornadoMesh = new THREE.Group();
            
            // Create spinning rings
            for (let i = 0; i < 5; i++) {
                const ring = new THREE.Mesh(
                    new THREE.TorusGeometry(2 + i * 0.5, 0.3, 8, 16),
                    new THREE.MeshBasicMaterial({ color: 0xaaffaa, transparent: true, opacity: 0.6 })
                );
                ring.position.y = i * 2;
                ring.userData = { speed: (i + 1) * 0.1 };
                tornadoMesh.add(ring);
            }
            
            tornadoMesh.position.copy(camera.position).add(new THREE.Vector3(0, 0, -10).applyQuaternion(camera.quaternion));
            scene.add(tornadoMesh);
            
            addTimedPowerup("üå™Ô∏è Tornado", 10000, () => {
                gameState.tornadoActive = false;
                scene.remove(tornadoMesh);
                tornadoMesh = null;
            });
        }
        
        function activateOrbitalStrike() {
            // Find all enemies and drop strikes on them
            enemies.forEach(enemy => {
                const strike = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 1.5, 30, 8),
                    new THREE.MeshBasicMaterial({ color: 0xff0088, transparent: true, opacity: 0.8 })
                );
                strike.position.set(enemy.position.x, 20, enemy.position.z);
                strike.userData = { falling: true, speed: 0.5, target: enemy.position.clone() };
                scene.add(strike);
                particles.push(strike);
            });
            
            setTimeout(() => {
                enemies.forEach(e => {
                    e.health -= 80;
                    createExplosion(e.position, 0xff0088, 15);
                });
            }, 1000);
        }

        function addTimedPowerup(name, duration, onEnd) {
            gameState.activePowerups = gameState.activePowerups.filter(p => p.name !== name);
            gameState.activePowerups.push({ name, endTime: Date.now() + duration, onEnd });
        }

        function spawnPowerup(position) {
            const totalWeight = POWERUP_TYPES.reduce((sum, p) => sum + p.rarity, 0);
            let rand = Math.random() * totalWeight;
            let powerup = POWERUP_TYPES[0];
            for (const p of POWERUP_TYPES) {
                rand -= p.rarity;
                if (rand <= 0) { powerup = p; break; }
            }
            
            const group = new THREE.Group();
            const glow = new THREE.Mesh(new THREE.SphereGeometry(0.9, 16, 16), new THREE.MeshBasicMaterial({ color: powerup.color, transparent: true, opacity: 0.4 }));
            group.add(glow);
            const core = new THREE.Mesh(new THREE.OctahedronGeometry(0.45, 0), new THREE.MeshStandardMaterial({ color: powerup.color, emissive: powerup.color, emissiveIntensity: 1 }));
            group.add(core);
            const ring = new THREE.Mesh(new THREE.TorusGeometry(0.6, 0.08, 8, 16), new THREE.MeshBasicMaterial({ color: powerup.color }));
            ring.rotation.x = Math.PI / 2;
            group.add(ring);
            
            group.position.copy(position);
            group.position.y = 1.5;
            group.powerupData = powerup;
            scene.add(group);
            powerupObjects.push({ mesh: group, powerup, time: 0 });
        }

        function showPowerupNotification(name) {
            const el = document.getElementById('powerupNotification');
            el.textContent = name;
            el.classList.add('show');
            setTimeout(() => el.classList.remove('show'), 1500);
        }

        function updatePowerups() {
            powerupObjects.forEach((obj, idx) => {
                obj.time++;
                obj.mesh.rotation.y += 0.05;
                obj.mesh.children[2].rotation.z += 0.05;
                obj.mesh.position.y = 1.5 + Math.sin(obj.time * 0.07) * 0.35;

                if (gameState.magnetActive || gameState.titanMode) {
                    const dir = new THREE.Vector3().subVectors(camera.position, obj.mesh.position);
                    if (dir.length() < 20) {
                        dir.normalize();
                        obj.mesh.position.addScaledVector(dir, 0.3);
                    }
                }

                const dist = obj.mesh.position.distanceTo(camera.position);
                if (dist < 3) {
                    obj.powerup.effect();
                    showPowerupNotification(obj.powerup.name);
                    createParticleBurst(obj.mesh.position, obj.powerup.color, 25);
                    scene.remove(obj.mesh);
                    powerupObjects.splice(idx, 1);
                }

                if (obj.time > 900) {
                    scene.remove(obj.mesh);
                    powerupObjects.splice(idx, 1);
                }
            });

            gameState.activePowerups = gameState.activePowerups.filter(p => {
                if (p.endTime <= Date.now()) {
                    if (p.onEnd) p.onEnd();
                    return false;
                }
                return true;
            });
        }

        // ===== PARTICLE SYSTEM =====
        const particles = [];
        function createParticle(pos, color, vel, life = 50) {
            const p = new THREE.Mesh(new THREE.SphereGeometry(0.15, 4, 4), new THREE.MeshBasicMaterial({ color, transparent: true }));
            p.position.copy(pos);
            p.velocity = vel;
            p.life = life;
            p.maxLife = life;
            scene.add(p);
            particles.push(p);
        }

        function createParticleBurst(pos, color, count) {
            // Reduced particle count
            const actualCount = Math.min(count, 15);
            for (let i = 0; i < actualCount; i++) {
                createParticle(pos.clone(), color, new THREE.Vector3((Math.random()-0.5)*0.5, Math.random()*0.5, (Math.random()-0.5)*0.5), 30);
            }
        }

        function createExplosion(pos, color, count) {
            // Reduced particle count
            const actualCount = Math.min(count, 12);
            createParticleBurst(pos, color, actualCount);
            const ring = new THREE.Mesh(new THREE.RingGeometry(0.5, 0.8, 16), new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.9, side: THREE.DoubleSide }));
            ring.position.copy(pos);
            ring.position.y = 1;
            ring.rotation.x = -Math.PI / 2;
            ring.userData = { expanding: true, life: 20 };
            scene.add(ring);
            particles.push(ring);
        }

        function updateParticles() {
            particles.forEach((p, idx) => {
                if (p.userData && p.userData.expanding) {
                    p.scale.x += 0.8;
                    p.scale.y += 0.8;
                    p.material.opacity -= 0.04;
                    p.userData.life--;
                    if (p.userData.life <= 0) { scene.remove(p); particles.splice(idx, 1); }
                } else if (p.userData && p.userData.falling) {
                    // Orbital strike falling
                    p.position.y -= p.userData.speed;
                    p.userData.speed += 0.1; // Accelerate
                    if (p.position.y <= 1) {
                        createExplosion(p.userData.target, 0xff0088, 15);
                        scene.remove(p);
                        particles.splice(idx, 1);
                    }
                } else {
                    p.position.add(p.velocity);
                    p.velocity.y -= 0.01;
                    p.life--;
                    p.material.opacity = p.life / p.maxLife;
                    if (p.life <= 0) { scene.remove(p); particles.splice(idx, 1); }
                }
            });
            
            if (dustSystem) {
                dustSystem.rotation.y += 0.0005;
                const pos = dustSystem.geometry.attributes.position.array;
                for(let i=1; i<pos.length; i+=3) {
                    pos[i] -= 0.02;
                    if(pos[i] < 0) pos[i] = 20;
                }
                dustSystem.geometry.attributes.position.needsUpdate = true;
            }
            
            // Animate Black Hole
            if (gameState.blackHoleActive && blackHoleMesh) {
                blackHoleMesh.children[0].rotation.z += 0.1;
                blackHoleMesh.scale.setScalar(1 + Math.sin(Date.now() * 0.01) * 0.1);
            }
            
            // Animate Tornado
            if (gameState.tornadoActive && tornadoMesh) {
                tornadoMesh.children.forEach(ring => {
                    ring.rotation.y += ring.userData.speed;
                });
                tornadoMesh.position.y = Math.sin(Date.now() * 0.002) * 2;
            }
        }

        // ===== PROJECTILE SYSTEM =====
        const projectiles = [];
        let lastFireTime = 0;
        const BASE_FIRE_RATE = 150;

        function createProjectile() {
            if (gameState.paused) return;
            
            if (gameState.inSafeRoom) {
                const warn = document.getElementById('warningNotification');
                warn.textContent = "üö´ WEAPONS DISABLED IN SAFE ROOM";
                warn.classList.add('show');
                setTimeout(() => warn.classList.remove('show'), 1500);
                return;
            }

            if (gameState.ammo <= 0 && !gameState.titanMode) {
                showQuestion();
                return;
            }
            
            const now = Date.now();
            const fireDelay = gameState.godBeamActive ? 20 : (BASE_FIRE_RATE / gameState.fireRateMultiplier);
            if (now - lastFireTime < fireDelay) return;
            lastFireTime = now;
            
            if (!gameState.godBeamActive && !gameState.titanMode) gameState.ammo--;

            const color = gameState.godBeamActive ? 0x00ffff : (gameState.titanMode ? 0xffaa00 : 0x00ff00);
            const scale = gameState.titanMode ? 0.8 : 0.18;
            
            const proj = new THREE.Mesh(
                new THREE.SphereGeometry(scale, 8, 8),
                new THREE.MeshBasicMaterial({ color: color })
            );
            
            proj.position.copy(camera.position);
            proj.position.y -= gameState.titanMode ? 1.0 : 0.2;
            
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            proj.velocity = forward.clone().multiplyScalar(gameState.godBeamActive ? 2.5 : 1.0);
            proj.life = 100;
            proj.hitEnemies = new Set();
            proj.isGodBeam = gameState.godBeamActive;

            scene.add(proj);
            projectiles.push(proj);
        }

        function showHitMarker() {
            const marker = document.getElementById('hitMarker');
            marker.classList.add('show');
            setTimeout(() => marker.classList.remove('show'), 100);
        }

        function updateProjectiles() {
            projectiles.forEach((proj, idx) => {
                // Auto-aim
                if (gameState.autoAimActive && enemies.length > 0) {
                    let closest = null;
                    let closestDist = 50;
                    enemies.forEach(e => {
                        const d = e.position.distanceTo(proj.position);
                        if (d < closestDist) { closest = e; closestDist = d; }
                    });
                    if (closest) {
                        const dir = new THREE.Vector3().subVectors(closest.position, proj.position).normalize();
                        proj.velocity.lerp(dir.multiplyScalar(proj.velocity.length()), 0.15);
                    }
                }
                
                proj.position.add(proj.velocity);
                proj.life--;

                if (proj.life <= 0) {
                    scene.remove(proj);
                    projectiles.splice(idx, 1);
                    return;
                }

                let hitEnemy = null;
                enemies.forEach(enemy => {
                    const dist = proj.position.distanceTo(enemy.position);
                    if ((dist < enemy.hitRadius || enemy.boundingBox.containsPoint(proj.position)) && !proj.hitEnemies.has(enemy)) {
                        hitEnemy = enemy;
                    }
                });

                if (hitEnemy) {
                    const damage = (gameState.titanMode ? 50 : 6) * gameState.damageMultiplier;
                    hitEnemy.health -= damage;
                    proj.hitEnemies.add(hitEnemy);
                    
                    createParticleBurst(proj.position, 0x00ff00, 3);
                    showHitMarker();
                    
                    // Lightning Chain - damage spreads to nearby enemies
                    if (gameState.lightningChainActive) {
                        enemies.forEach(e => {
                            if (e !== hitEnemy && e.position.distanceTo(hitEnemy.position) < 8) {
                                e.health -= damage * 0.5;
                                // Visual lightning effect
                                createParticleBurst(e.position, 0xffff00, 2);
                            }
                        });
                    }
                    
                    if (!gameState.piercingActive && !proj.isGodBeam && !gameState.titanMode) {
                        scene.remove(proj);
                        projectiles.splice(idx, 1);
                    }
                }
            });
        }
        
        // ===== BOMB SYSTEM =====
        const bombs = [];
        function dropBomb() {
            if (gameState.paused || gameState.inSafeRoom) return;
            if (gameState.bombs <= 0) return;
            gameState.bombs--;
            
            const bomb = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), new THREE.MeshStandardMaterial({ color: 0x222222, emissive: 0xff0044, emissiveIntensity: 1 }));
            bomb.position.copy(camera.position);
            bomb.position.y = 0.6;
            bomb.timer = 80;
            scene.add(bomb);
            bombs.push(bomb);
        }

        function updateBombs() {
            bombs.forEach((bomb, idx) => {
                bomb.timer--;
                bomb.scale.setScalar(1 + Math.sin(Date.now() * 0.05) * 0.2);
                if (bomb.timer <= 0) {
                    createExplosion(bomb.position, 0xff4400, 60);
                    enemies.forEach(enemy => {
                        const dist = enemy.position.distanceTo(bomb.position);
                        if (dist < 18) enemy.health -= 50 * (1 - dist / 18);
                    });
                    scene.remove(bomb);
                    bombs.splice(idx, 1);
                }
            });
        }

        // ===== QUESTION SYSTEM =====
        function showQuestion(fromSafeRoom = false) {
            if (gameState.questionActive || gameState.gameOver) return;
            
            // Exit pointer lock to show cursor
            if (document.pointerLockElement) {
                document.exitPointerLock();
            }
            
            gameState.questionActive = true;
            gameState.paused = true;
            gameState.pauseStartTime = Date.now();
            gameState.safeRoomMode = fromSafeRoom;
            
            document.getElementById('pausedOverlay').classList.add('show');
            
            if (questionIndex >= shuffledQuestions.length) {
                shuffledQuestions = shuffleArray([...QUESTION_POOL]);
                questionIndex = 0;
            }
            
            const q = shuffledQuestions[questionIndex++];
            const correctAnswer = q.a[q.c];
            const shuffledAnswers = [...q.a];
            for (let i = shuffledAnswers.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledAnswers[i], shuffledAnswers[j]] = [shuffledAnswers[j], shuffledAnswers[i]];
            }
            
            gameState.currentQuestion = { q: q.q, a: shuffledAnswers, c: shuffledAnswers.indexOf(correctAnswer), cat: q.cat };
            
            document.getElementById('questionCategory').textContent = fromSafeRoom ? 'üìö SAFE ROOM STUDY - ' + q.cat : q.cat;
            document.getElementById('questionText').textContent = q.q;
            document.getElementById('feedback').textContent = '';
            document.getElementById('feedback').className = '';
            
            const options = document.getElementById('optionsContainer');
            options.innerHTML = '';
            
            shuffledAnswers.forEach((answer, idx) => {
                const btn = document.createElement('button');
                btn.className = 'option-button';
                btn.textContent = answer;
                btn.onclick = () => checkAnswer(idx);
                options.appendChild(btn);
            });
            
            document.getElementById('questionModal').classList.add('active');
        }

        function checkAnswer(idx) {
            const q = gameState.currentQuestion;
            const correct = idx === q.c;
            const inSafeRoom = gameState.safeRoomMode;
            
            document.querySelectorAll('.option-button').forEach((btn, i) => {
                btn.disabled = true;
                if (i === q.c) btn.classList.add('correct');
                if (i === idx && i !== q.c) btn.classList.add('incorrect');
            });
            
            const feedback = document.getElementById('feedback');
            if (correct) {
                let bonus = 50 + gameState.streak * 10;
                feedback.textContent = `‚úì Correct! +25 Ammo, +${bonus} Score`;
                feedback.className = 'correct';
                gameState.ammo = Math.min(gameState.maxAmmo, gameState.ammo + 25);
                gameState.correct++;
                gameState.score += bonus;
                gameState.streak++;
                
                const offset = new THREE.Vector3((Math.random()-0.5)*(inSafeRoom?2:8), 0, (Math.random()-0.5)*(inSafeRoom?2:8));
                spawnPowerup(inSafeRoom ? new THREE.Vector3(SAFE_ROOM.x + 12, 0, SAFE_ROOM.z) : camera.position.clone().add(offset));
            } else {
                const healthPenalty = inSafeRoom ? 5 : 20;
                feedback.textContent = `‚úó Wrong! -${healthPenalty} Health`;
                feedback.className = 'incorrect';
                gameState.health -= healthPenalty;
                gameState.wrong++;
                gameState.streak = 0;
                showDamageFlash();
            }
            
            setTimeout(() => {
                document.getElementById('questionModal').classList.remove('active');
                document.getElementById('pausedOverlay').classList.remove('show');
                gameState.questionActive = false;
                gameState.safeRoomMode = false;
                
                const pauseDuration = Date.now() - gameState.pauseStartTime;
                gameState.activePowerups.forEach(p => { p.endTime += pauseDuration; });
                
                gameState.paused = false;
                animate();
            }, 1800);
        }

        function showDamageFlash() {
            const flash = document.getElementById('damageFlash');
            flash.classList.add('active');
            setTimeout(() => flash.classList.remove('active'), 120);
        }

        // ===== MINIMAP =====
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        minimapCanvas.width = 120; minimapCanvas.height = 120;

        function updateMinimap() {
            minimapCtx.fillStyle = 'rgba(0, 15, 30, 0.95)';
            minimapCtx.fillRect(0, 0, 120, 120);
            const scale = 120 / (ARENA_SIZE * 2);
            const ox = 60, oy = 60;
            
            minimapCtx.fillStyle = 'rgba(0, 255, 100, 0.3)';
            minimapCtx.fillRect((SAFE_ROOM.x - SAFE_ROOM.width/2) * scale + ox, (SAFE_ROOM.z - SAFE_ROOM.depth/2) * scale + oy, SAFE_ROOM.width * scale, SAFE_ROOM.depth * scale);
            
            enemies.forEach(e => {
                minimapCtx.fillStyle = e.enemyType.kamikaze ? '#ff0000' : '#ff3333';
                minimapCtx.beginPath();
                minimapCtx.arc(e.position.x * scale + ox, e.position.z * scale + oy, 2, 0, Math.PI * 2);
                minimapCtx.fill();
            });
            
            minimapCtx.fillStyle = '#00ffff';
            minimapCtx.beginPath();
            minimapCtx.arc(camera.position.x * scale + ox, camera.position.z * scale + oy, 3, 0, Math.PI * 2);
            minimapCtx.fill();
        }

        // ===== MAIN LOOP =====
        function checkLevelProgress() {
            const newLevel = Math.floor((gameState.correct * 3 + gameState.score / 400) / 10) + 1;
            if (newLevel > gameState.level && newLevel <= 10) {
                gameState.level = newLevel;
                const indicator = document.getElementById('levelIndicator');
                indicator.textContent = `LEVEL ${newLevel}`;
                indicator.classList.add('show');
                setTimeout(() => indicator.classList.remove('show'), 2500);
                generateLevel(newLevel);
                gameState.health = Math.min(gameState.maxHealth, gameState.health + 30);
                gameState.ammo = Math.min(gameState.maxAmmo, gameState.ammo + 20);
            }
        }
        
        let shieldMesh = null;
        function updateShieldVisual() {
            if (gameState.shieldActive && !shieldMesh) {
                shieldMesh = new THREE.Mesh(new THREE.SphereGeometry(2.5, 20, 20), new THREE.MeshBasicMaterial({ color: 0x4488ff, transparent: true, opacity: 0.2, wireframe: true }));
                scene.add(shieldMesh);
            }
            if (shieldMesh) {
                if (gameState.shieldActive) {
                    shieldMesh.position.copy(camera.position);
                    shieldMesh.rotation.y += 0.05;
                } else {
                    scene.remove(shieldMesh);
                    shieldMesh = null;
                }
            }
        }

        function animate() {
            if (gameState.gameOver) return;
            if (gameState.paused) return;
            
            requestAnimationFrame(animate);

            // Movement
            const moveSpeed = (gameState.titanMode ? 0.35 : 0.18) * gameState.speedMultiplier;
            const moveDir = new THREE.Vector3();
            
            // WASD and Arrow Keys
            if (keys['w'] || keys['ArrowUp']) moveDir.z -= 1;
            if (keys['s'] || keys['ArrowDown']) moveDir.z += 1;
            if (keys['a'] || keys['ArrowLeft']) moveDir.x -= 1;
            if (keys['d'] || keys['ArrowRight']) moveDir.x += 1;
            
            if (moveDir.length() > 0) {
                moveDir.normalize();
                moveDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), camera.rotation.y);
                camera.position.addScaledVector(moveDir, moveSpeed);
                camera.position.x = Math.max(-ARENA_SIZE + 2, Math.min(ARENA_SIZE - 2, camera.position.x));
                camera.position.z = Math.max(-ARENA_SIZE + 2, Math.min(ARENA_SIZE - 2, camera.position.z));
            }

            // Auto fire
            if (keys[' '] && !gameState.questionActive) {
                createProjectile();
            }

            updateEnemies();
            updatePowerups();
            updateProjectiles();
            updateParticles();
            updateBombs();
            updateTraps();
            updateShieldVisual();
            updateMinimap();
            updateSafeRoomStatus();
            checkLevelProgress();

            // UI
            document.getElementById('health').textContent = Math.ceil(gameState.health);
            document.getElementById('healthBar').style.width = (gameState.health / gameState.maxHealth * 100) + '%';
            document.getElementById('ammo').textContent = gameState.ammo;
            document.getElementById('ammoBar').style.width = (gameState.ammo / gameState.maxAmmo * 100) + '%';
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('streak').textContent = gameState.streak;
            document.getElementById('level').textContent = gameState.level;
            document.getElementById('bombCount').textContent = gameState.bombs;
            document.getElementById('enemyCount').textContent = enemies.length;
            document.getElementById('correct').textContent = gameState.correct;
            document.getElementById('wrong').textContent = gameState.wrong;

            document.getElementById('powerupsList').innerHTML = gameState.activePowerups.map(p => {
                const rem = Math.max(0, Math.ceil((p.endTime - Date.now()) / 1000));
                return `<div class="powerup-item">${p.name} (${rem}s)</div>`;
            }).join('');

            if (gameState.health <= 0) {
                gameState.gameOver = true;
                document.getElementById('gameOverText').innerHTML = `
                    <div style="font-size: 26px; margin-bottom: 12px;">üíÄ GAME OVER</div>
                    <div>Score: <span style="color: #0ff;">${gameState.score}</span></div>
                    <div>Level: <span style="color: #0ff;">${gameState.level}</span></div>
                    <div>Correct: <span style="color: #0f0;">${gameState.correct}</span> / Wrong: <span style="color: #f44;">${gameState.wrong}</span></div>
                `;
                document.getElementById('gameMessage').style.display = 'block';
            }

            renderer.render(scene, camera);
        }

        generateLevel(1);
        for (let i = 0; i < 4; i++) createEnemy();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
